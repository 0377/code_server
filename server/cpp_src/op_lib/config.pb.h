// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef PROTOBUF_config_2eproto__INCLUDED
#define PROTOBUF_config_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class CommonServer_Config;
class CommonServer_ConfigDefaultTypeInternal;
extern CommonServer_ConfigDefaultTypeInternal _CommonServer_Config_default_instance_;
class ConfigServer_Config;
class ConfigServer_ConfigDefaultTypeInternal;
extern ConfigServer_ConfigDefaultTypeInternal _ConfigServer_Config_default_instance_;
class DBConnectOption;
class DBConnectOptionDefaultTypeInternal;
extern DBConnectOptionDefaultTypeInternal _DBConnectOption_default_instance_;
class DBServerConfig;
class DBServerConfigDefaultTypeInternal;
extern DBServerConfigDefaultTypeInternal _DBServerConfig_default_instance_;
class GameServerConfigInfo;
class GameServerConfigInfoDefaultTypeInternal;
extern GameServerConfigInfoDefaultTypeInternal _GameServerConfigInfo_default_instance_;
class GateServerConfigInfo;
class GateServerConfigInfoDefaultTypeInternal;
extern GateServerConfigInfoDefaultTypeInternal _GateServerConfigInfo_default_instance_;
class LoginServerConfigInfo;
class LoginServerConfigInfoDefaultTypeInternal;
extern LoginServerConfigInfoDefaultTypeInternal _LoginServerConfigInfo_default_instance_;
class NetworkAddress;
class NetworkAddressDefaultTypeInternal;
extern NetworkAddressDefaultTypeInternal _NetworkAddress_default_instance_;
class PrivateRoomInfoConfig;
class PrivateRoomInfoConfigDefaultTypeInternal;
extern PrivateRoomInfoConfigDefaultTypeInternal _PrivateRoomInfoConfig_default_instance_;
class PrivateRoomListConfig;
class PrivateRoomListConfigDefaultTypeInternal;
extern PrivateRoomListConfigDefaultTypeInternal _PrivateRoomListConfig_default_instance_;
class RedisConnectOption;
class RedisConnectOptionDefaultTypeInternal;
extern RedisConnectOptionDefaultTypeInternal _RedisConnectOption_default_instance_;
class RedisSentinelOption;
class RedisSentinelOptionDefaultTypeInternal;
extern RedisSentinelOptionDefaultTypeInternal _RedisSentinelOption_default_instance_;

namespace protobuf_config_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_config_2eproto

// ===================================================================

class NetworkAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetworkAddress) */ {
 public:
  NetworkAddress();
  virtual ~NetworkAddress();

  NetworkAddress(const NetworkAddress& from);

  inline NetworkAddress& operator=(const NetworkAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkAddress& default_instance();

  static inline const NetworkAddress* internal_default_instance() {
    return reinterpret_cast<const NetworkAddress*>(
               &_NetworkAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(NetworkAddress* other);

  // implements Message ----------------------------------------------

  inline NetworkAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkAddress& from);
  void MergeFrom(const NetworkAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional int32 server_id = 3;
  bool has_server_id() const;
  void clear_server_id();
  static const int kServerIdFieldNumber = 3;
  ::google::protobuf::int32 server_id() const;
  void set_server_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NetworkAddress)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();
  void set_has_server_id();
  void clear_has_server_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 server_id_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DBConnectOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DBConnectOption) */ {
 public:
  DBConnectOption();
  virtual ~DBConnectOption();

  DBConnectOption(const DBConnectOption& from);

  inline DBConnectOption& operator=(const DBConnectOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBConnectOption& default_instance();

  static inline const DBConnectOption* internal_default_instance() {
    return reinterpret_cast<const DBConnectOption*>(
               &_DBConnectOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DBConnectOption* other);

  // implements Message ----------------------------------------------

  inline DBConnectOption* New() const PROTOBUF_FINAL { return New(NULL); }

  DBConnectOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DBConnectOption& from);
  void MergeFrom(const DBConnectOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DBConnectOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string host = 1;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // required string user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // required string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required string database = 4;
  bool has_database() const;
  void clear_database();
  static const int kDatabaseFieldNumber = 4;
  const ::std::string& database() const;
  void set_database(const ::std::string& value);
  #if LANG_CXX11
  void set_database(::std::string&& value);
  #endif
  void set_database(const char* value);
  void set_database(const char* value, size_t size);
  ::std::string* mutable_database();
  ::std::string* release_database();
  void set_allocated_database(::std::string* database);

  // @@protoc_insertion_point(class_scope:DBConnectOption)
 private:
  void set_has_host();
  void clear_has_host();
  void set_has_user();
  void clear_has_user();
  void set_has_password();
  void clear_has_password();
  void set_has_database();
  void clear_has_database();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr database_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedisConnectOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RedisConnectOption) */ {
 public:
  RedisConnectOption();
  virtual ~RedisConnectOption();

  RedisConnectOption(const RedisConnectOption& from);

  inline RedisConnectOption& operator=(const RedisConnectOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedisConnectOption& default_instance();

  static inline const RedisConnectOption* internal_default_instance() {
    return reinterpret_cast<const RedisConnectOption*>(
               &_RedisConnectOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RedisConnectOption* other);

  // implements Message ----------------------------------------------

  inline RedisConnectOption* New() const PROTOBUF_FINAL { return New(NULL); }

  RedisConnectOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedisConnectOption& from);
  void MergeFrom(const RedisConnectOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedisConnectOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional string password = 4;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 4;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional int32 dbnum = 3;
  bool has_dbnum() const;
  void clear_dbnum();
  static const int kDbnumFieldNumber = 3;
  ::google::protobuf::int32 dbnum() const;
  void set_dbnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RedisConnectOption)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();
  void set_has_dbnum();
  void clear_has_dbnum();
  void set_has_password();
  void clear_has_password();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 dbnum_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedisSentinelOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RedisSentinelOption) */ {
 public:
  RedisSentinelOption();
  virtual ~RedisSentinelOption();

  RedisSentinelOption(const RedisSentinelOption& from);

  inline RedisSentinelOption& operator=(const RedisSentinelOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedisSentinelOption& default_instance();

  static inline const RedisSentinelOption* internal_default_instance() {
    return reinterpret_cast<const RedisSentinelOption*>(
               &_RedisSentinelOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RedisSentinelOption* other);

  // implements Message ----------------------------------------------

  inline RedisSentinelOption* New() const PROTOBUF_FINAL { return New(NULL); }

  RedisSentinelOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedisSentinelOption& from);
  void MergeFrom(const RedisSentinelOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedisSentinelOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required string master_name = 4;
  bool has_master_name() const;
  void clear_master_name();
  static const int kMasterNameFieldNumber = 4;
  const ::std::string& master_name() const;
  void set_master_name(const ::std::string& value);
  #if LANG_CXX11
  void set_master_name(::std::string&& value);
  #endif
  void set_master_name(const char* value);
  void set_master_name(const char* value, size_t size);
  ::std::string* mutable_master_name();
  ::std::string* release_master_name();
  void set_allocated_master_name(::std::string* master_name);

  // optional string password = 5;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 5;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional int32 dbnum = 3;
  bool has_dbnum() const;
  void clear_dbnum();
  static const int kDbnumFieldNumber = 3;
  ::google::protobuf::int32 dbnum() const;
  void set_dbnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RedisSentinelOption)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();
  void set_has_dbnum();
  void clear_has_dbnum();
  void set_has_master_name();
  void clear_has_master_name();
  void set_has_password();
  void clear_has_password();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr master_name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 dbnum_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfigServer_Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ConfigServer_Config) */ {
 public:
  ConfigServer_Config();
  virtual ~ConfigServer_Config();

  ConfigServer_Config(const ConfigServer_Config& from);

  inline ConfigServer_Config& operator=(const ConfigServer_Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigServer_Config& default_instance();

  static inline const ConfigServer_Config* internal_default_instance() {
    return reinterpret_cast<const ConfigServer_Config*>(
               &_ConfigServer_Config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ConfigServer_Config* other);

  // implements Message ----------------------------------------------

  inline ConfigServer_Config* New() const PROTOBUF_FINAL { return New(NULL); }

  ConfigServer_Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConfigServer_Config& from);
  void MergeFrom(const ConfigServer_Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConfigServer_Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DBConnectOption config_db = 2;
  bool has_config_db() const;
  void clear_config_db();
  static const int kConfigDbFieldNumber = 2;
  const ::DBConnectOption& config_db() const;
  ::DBConnectOption* mutable_config_db();
  ::DBConnectOption* release_config_db();
  void set_allocated_config_db(::DBConnectOption* config_db);

  // required .DBConnectOption config_game = 3;
  bool has_config_game() const;
  void clear_config_game();
  static const int kConfigGameFieldNumber = 3;
  const ::DBConnectOption& config_game() const;
  ::DBConnectOption* mutable_config_game();
  ::DBConnectOption* release_config_game();
  void set_allocated_config_game(::DBConnectOption* config_game);

  // required int32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional bool log_print_open = 4;
  bool has_log_print_open() const;
  void clear_log_print_open();
  static const int kLogPrintOpenFieldNumber = 4;
  bool log_print_open() const;
  void set_log_print_open(bool value);

  // @@protoc_insertion_point(class_scope:ConfigServer_Config)
 private:
  void set_has_port();
  void clear_has_port();
  void set_has_config_db();
  void clear_has_config_db();
  void set_has_config_game();
  void clear_has_config_game();
  void set_has_log_print_open();
  void clear_has_log_print_open();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::DBConnectOption* config_db_;
  ::DBConnectOption* config_game_;
  ::google::protobuf::int32 port_;
  bool log_print_open_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommonServer_Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CommonServer_Config) */ {
 public:
  CommonServer_Config();
  virtual ~CommonServer_Config();

  CommonServer_Config(const CommonServer_Config& from);

  inline CommonServer_Config& operator=(const CommonServer_Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonServer_Config& default_instance();

  static inline const CommonServer_Config* internal_default_instance() {
    return reinterpret_cast<const CommonServer_Config*>(
               &_CommonServer_Config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(CommonServer_Config* other);

  // implements Message ----------------------------------------------

  inline CommonServer_Config* New() const PROTOBUF_FINAL { return New(NULL); }

  CommonServer_Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommonServer_Config& from);
  void MergeFrom(const CommonServer_Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommonServer_Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkAddress config_addr = 1;
  bool has_config_addr() const;
  void clear_config_addr();
  static const int kConfigAddrFieldNumber = 1;
  const ::NetworkAddress& config_addr() const;
  ::NetworkAddress* mutable_config_addr();
  ::NetworkAddress* release_config_addr();
  void set_allocated_config_addr(::NetworkAddress* config_addr);

  // optional bool log_print_open = 2;
  bool has_log_print_open() const;
  void clear_log_print_open();
  static const int kLogPrintOpenFieldNumber = 2;
  bool log_print_open() const;
  void set_log_print_open(bool value);

  // @@protoc_insertion_point(class_scope:CommonServer_Config)
 private:
  void set_has_config_addr();
  void clear_has_config_addr();
  void set_has_log_print_open();
  void clear_has_log_print_open();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::NetworkAddress* config_addr_;
  bool log_print_open_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginServerConfigInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LoginServerConfigInfo) */ {
 public:
  LoginServerConfigInfo();
  virtual ~LoginServerConfigInfo();

  LoginServerConfigInfo(const LoginServerConfigInfo& from);

  inline LoginServerConfigInfo& operator=(const LoginServerConfigInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginServerConfigInfo& default_instance();

  static inline const LoginServerConfigInfo* internal_default_instance() {
    return reinterpret_cast<const LoginServerConfigInfo*>(
               &_LoginServerConfigInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(LoginServerConfigInfo* other);

  // implements Message ----------------------------------------------

  inline LoginServerConfigInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginServerConfigInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginServerConfigInfo& from);
  void MergeFrom(const LoginServerConfigInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginServerConfigInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NetworkAddress db_addr = 3;
  int db_addr_size() const;
  void clear_db_addr();
  static const int kDbAddrFieldNumber = 3;
  const ::NetworkAddress& db_addr(int index) const;
  ::NetworkAddress* mutable_db_addr(int index);
  ::NetworkAddress* add_db_addr();
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
      mutable_db_addr();
  const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
      db_addr() const;

  // repeated .RedisSentinelOption def_sentinel = 5;
  int def_sentinel_size() const;
  void clear_def_sentinel();
  static const int kDefSentinelFieldNumber = 5;
  const ::RedisSentinelOption& def_sentinel(int index) const;
  ::RedisSentinelOption* mutable_def_sentinel(int index);
  ::RedisSentinelOption* add_def_sentinel();
  ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >*
      mutable_def_sentinel();
  const ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >&
      def_sentinel() const;

  // optional .RedisConnectOption def_redis = 4;
  bool has_def_redis() const;
  void clear_def_redis();
  static const int kDefRedisFieldNumber = 4;
  const ::RedisConnectOption& def_redis() const;
  ::RedisConnectOption* mutable_def_redis();
  ::RedisConnectOption* release_def_redis();
  void set_allocated_def_redis(::RedisConnectOption* def_redis);

  // required int32 login_id = 1;
  bool has_login_id() const;
  void clear_login_id();
  static const int kLoginIdFieldNumber = 1;
  ::google::protobuf::int32 login_id() const;
  void set_login_id(::google::protobuf::int32 value);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginServerConfigInfo)
 private:
  void set_has_login_id();
  void clear_has_login_id();
  void set_has_port();
  void clear_has_port();
  void set_has_def_redis();
  void clear_has_def_redis();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress > db_addr_;
  ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption > def_sentinel_;
  ::RedisConnectOption* def_redis_;
  ::google::protobuf::int32 login_id_;
  ::google::protobuf::int32 port_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameServerConfigInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameServerConfigInfo) */ {
 public:
  GameServerConfigInfo();
  virtual ~GameServerConfigInfo();

  GameServerConfigInfo(const GameServerConfigInfo& from);

  inline GameServerConfigInfo& operator=(const GameServerConfigInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerConfigInfo& default_instance();

  static inline const GameServerConfigInfo* internal_default_instance() {
    return reinterpret_cast<const GameServerConfigInfo*>(
               &_GameServerConfigInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GameServerConfigInfo* other);

  // implements Message ----------------------------------------------

  inline GameServerConfigInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  GameServerConfigInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameServerConfigInfo& from);
  void MergeFrom(const GameServerConfigInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameServerConfigInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NetworkAddress login_addr = 15;
  int login_addr_size() const;
  void clear_login_addr();
  static const int kLoginAddrFieldNumber = 15;
  const ::NetworkAddress& login_addr(int index) const;
  ::NetworkAddress* mutable_login_addr(int index);
  ::NetworkAddress* add_login_addr();
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
      mutable_login_addr();
  const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
      login_addr() const;

  // repeated .NetworkAddress db_addr = 16;
  int db_addr_size() const;
  void clear_db_addr();
  static const int kDbAddrFieldNumber = 16;
  const ::NetworkAddress& db_addr(int index) const;
  ::NetworkAddress* mutable_db_addr(int index);
  ::NetworkAddress* add_db_addr();
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
      mutable_db_addr();
  const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
      db_addr() const;

  // repeated .RedisSentinelOption def_sentinel = 18;
  int def_sentinel_size() const;
  void clear_def_sentinel();
  static const int kDefSentinelFieldNumber = 18;
  const ::RedisSentinelOption& def_sentinel(int index) const;
  ::RedisSentinelOption* mutable_def_sentinel(int index);
  ::RedisSentinelOption* add_def_sentinel();
  ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >*
      mutable_def_sentinel();
  const ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >&
      def_sentinel() const;

  // optional string room_lua_cfg = 14;
  bool has_room_lua_cfg() const;
  void clear_room_lua_cfg();
  static const int kRoomLuaCfgFieldNumber = 14;
  const ::std::string& room_lua_cfg() const;
  void set_room_lua_cfg(const ::std::string& value);
  #if LANG_CXX11
  void set_room_lua_cfg(::std::string&& value);
  #endif
  void set_room_lua_cfg(const char* value);
  void set_room_lua_cfg(const char* value, size_t size);
  ::std::string* mutable_room_lua_cfg();
  ::std::string* release_room_lua_cfg();
  void set_allocated_room_lua_cfg(::std::string* room_lua_cfg);

  // optional .RedisConnectOption def_redis = 17;
  bool has_def_redis() const;
  void clear_def_redis();
  static const int kDefRedisFieldNumber = 17;
  const ::RedisConnectOption& def_redis() const;
  ::RedisConnectOption* mutable_def_redis();
  ::RedisConnectOption* release_def_redis();
  void set_allocated_def_redis(::RedisConnectOption* def_redis);

  // required int32 game_id = 1;
  bool has_game_id() const;
  void clear_game_id();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::int32 game_id() const;
  void set_game_id(::google::protobuf::int32 value);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional int32 using_login_validatebox = 3;
  bool has_using_login_validatebox() const;
  void clear_using_login_validatebox();
  static const int kUsingLoginValidateboxFieldNumber = 3;
  ::google::protobuf::int32 using_login_validatebox() const;
  void set_using_login_validatebox(::google::protobuf::int32 value);

  // optional int32 default_lobby = 4;
  bool has_default_lobby() const;
  void clear_default_lobby();
  static const int kDefaultLobbyFieldNumber = 4;
  ::google::protobuf::int32 default_lobby() const;
  void set_default_lobby(::google::protobuf::int32 value);

  // optional int32 first_game_type = 5;
  bool has_first_game_type() const;
  void clear_first_game_type();
  static const int kFirstGameTypeFieldNumber = 5;
  ::google::protobuf::int32 first_game_type() const;
  void set_first_game_type(::google::protobuf::int32 value);

  // optional int32 second_game_type = 6;
  bool has_second_game_type() const;
  void clear_second_game_type();
  static const int kSecondGameTypeFieldNumber = 6;
  ::google::protobuf::int32 second_game_type() const;
  void set_second_game_type(::google::protobuf::int32 value);

  // optional int32 player_limit = 7;
  bool has_player_limit() const;
  void clear_player_limit();
  static const int kPlayerLimitFieldNumber = 7;
  ::google::protobuf::int32 player_limit() const;
  void set_player_limit(::google::protobuf::int32 value);

  // optional int32 table_count = 8;
  bool has_table_count() const;
  void clear_table_count();
  static const int kTableCountFieldNumber = 8;
  ::google::protobuf::int32 table_count() const;
  void set_table_count(::google::protobuf::int32 value);

  // optional int32 money_limit = 9;
  bool has_money_limit() const;
  void clear_money_limit();
  static const int kMoneyLimitFieldNumber = 9;
  ::google::protobuf::int32 money_limit() const;
  void set_money_limit(::google::protobuf::int32 value);

  // optional int32 cell_money = 10;
  bool has_cell_money() const;
  void clear_cell_money();
  static const int kCellMoneyFieldNumber = 10;
  ::google::protobuf::int32 cell_money() const;
  void set_cell_money(::google::protobuf::int32 value);

  // optional int32 tax_open = 11;
  bool has_tax_open() const;
  void clear_tax_open();
  static const int kTaxOpenFieldNumber = 11;
  ::google::protobuf::int32 tax_open() const;
  void set_tax_open(::google::protobuf::int32 value);

  // optional int32 tax_show = 12;
  bool has_tax_show() const;
  void clear_tax_show();
  static const int kTaxShowFieldNumber = 12;
  ::google::protobuf::int32 tax_show() const;
  void set_tax_show(::google::protobuf::int32 value);

  // optional int32 tax = 13;
  bool has_tax() const;
  void clear_tax();
  static const int kTaxFieldNumber = 13;
  ::google::protobuf::int32 tax() const;
  void set_tax(::google::protobuf::int32 value);

  // optional int32 bank_transfer_tax = 19;
  bool has_bank_transfer_tax() const;
  void clear_bank_transfer_tax();
  static const int kBankTransferTaxFieldNumber = 19;
  ::google::protobuf::int32 bank_transfer_tax() const;
  void set_bank_transfer_tax(::google::protobuf::int32 value);

  // optional int32 register_money = 20;
  bool has_register_money() const;
  void clear_register_money();
  static const int kRegisterMoneyFieldNumber = 20;
  ::google::protobuf::int32 register_money() const;
  void set_register_money(::google::protobuf::int32 value);

  // optional int32 private_room_bank = 21;
  bool has_private_room_bank() const;
  void clear_private_room_bank();
  static const int kPrivateRoomBankFieldNumber = 21;
  ::google::protobuf::int32 private_room_bank() const;
  void set_private_room_bank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameServerConfigInfo)
 private:
  void set_has_game_id();
  void clear_has_game_id();
  void set_has_port();
  void clear_has_port();
  void set_has_using_login_validatebox();
  void clear_has_using_login_validatebox();
  void set_has_default_lobby();
  void clear_has_default_lobby();
  void set_has_first_game_type();
  void clear_has_first_game_type();
  void set_has_second_game_type();
  void clear_has_second_game_type();
  void set_has_player_limit();
  void clear_has_player_limit();
  void set_has_table_count();
  void clear_has_table_count();
  void set_has_money_limit();
  void clear_has_money_limit();
  void set_has_cell_money();
  void clear_has_cell_money();
  void set_has_tax_open();
  void clear_has_tax_open();
  void set_has_tax_show();
  void clear_has_tax_show();
  void set_has_tax();
  void clear_has_tax();
  void set_has_room_lua_cfg();
  void clear_has_room_lua_cfg();
  void set_has_def_redis();
  void clear_has_def_redis();
  void set_has_bank_transfer_tax();
  void clear_has_bank_transfer_tax();
  void set_has_register_money();
  void clear_has_register_money();
  void set_has_private_room_bank();
  void clear_has_private_room_bank();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress > login_addr_;
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress > db_addr_;
  ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption > def_sentinel_;
  ::google::protobuf::internal::ArenaStringPtr room_lua_cfg_;
  ::RedisConnectOption* def_redis_;
  ::google::protobuf::int32 game_id_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 using_login_validatebox_;
  ::google::protobuf::int32 default_lobby_;
  ::google::protobuf::int32 first_game_type_;
  ::google::protobuf::int32 second_game_type_;
  ::google::protobuf::int32 player_limit_;
  ::google::protobuf::int32 table_count_;
  ::google::protobuf::int32 money_limit_;
  ::google::protobuf::int32 cell_money_;
  ::google::protobuf::int32 tax_open_;
  ::google::protobuf::int32 tax_show_;
  ::google::protobuf::int32 tax_;
  ::google::protobuf::int32 bank_transfer_tax_;
  ::google::protobuf::int32 register_money_;
  ::google::protobuf::int32 private_room_bank_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GateServerConfigInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GateServerConfigInfo) */ {
 public:
  GateServerConfigInfo();
  virtual ~GateServerConfigInfo();

  GateServerConfigInfo(const GateServerConfigInfo& from);

  inline GateServerConfigInfo& operator=(const GateServerConfigInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GateServerConfigInfo& default_instance();

  static inline const GateServerConfigInfo* internal_default_instance() {
    return reinterpret_cast<const GateServerConfigInfo*>(
               &_GateServerConfigInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GateServerConfigInfo* other);

  // implements Message ----------------------------------------------

  inline GateServerConfigInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  GateServerConfigInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GateServerConfigInfo& from);
  void MergeFrom(const GateServerConfigInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GateServerConfigInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NetworkAddress login_addr = 6;
  int login_addr_size() const;
  void clear_login_addr();
  static const int kLoginAddrFieldNumber = 6;
  const ::NetworkAddress& login_addr(int index) const;
  ::NetworkAddress* mutable_login_addr(int index);
  ::NetworkAddress* add_login_addr();
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
      mutable_login_addr();
  const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
      login_addr() const;

  // repeated .NetworkAddress game_addr = 7;
  int game_addr_size() const;
  void clear_game_addr();
  static const int kGameAddrFieldNumber = 7;
  const ::NetworkAddress& game_addr(int index) const;
  ::NetworkAddress* mutable_game_addr(int index);
  ::NetworkAddress* add_game_addr();
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
      mutable_game_addr();
  const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
      game_addr() const;

  // optional string sms_url = 5;
  bool has_sms_url() const;
  void clear_sms_url();
  static const int kSmsUrlFieldNumber = 5;
  const ::std::string& sms_url() const;
  void set_sms_url(const ::std::string& value);
  #if LANG_CXX11
  void set_sms_url(::std::string&& value);
  #endif
  void set_sms_url(const char* value);
  void set_sms_url(const char* value, size_t size);
  ::std::string* mutable_sms_url();
  ::std::string* release_sms_url();
  void set_allocated_sms_url(::std::string* sms_url);

  // optional string sms_sign_key = 8;
  bool has_sms_sign_key() const;
  void clear_sms_sign_key();
  static const int kSmsSignKeyFieldNumber = 8;
  const ::std::string& sms_sign_key() const;
  void set_sms_sign_key(const ::std::string& value);
  #if LANG_CXX11
  void set_sms_sign_key(::std::string&& value);
  #endif
  void set_sms_sign_key(const char* value);
  void set_sms_sign_key(const char* value, size_t size);
  ::std::string* mutable_sms_sign_key();
  ::std::string* release_sms_sign_key();
  void set_allocated_sms_sign_key(::std::string* sms_sign_key);

  // required int32 gate_id = 1;
  bool has_gate_id() const;
  void clear_gate_id();
  static const int kGateIdFieldNumber = 1;
  ::google::protobuf::int32 gate_id() const;
  void set_gate_id(::google::protobuf::int32 value);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional int32 timeout_limit = 3;
  bool has_timeout_limit() const;
  void clear_timeout_limit();
  static const int kTimeoutLimitFieldNumber = 3;
  ::google::protobuf::int32 timeout_limit() const;
  void set_timeout_limit(::google::protobuf::int32 value);

  // optional int32 sms_time_limit = 4;
  bool has_sms_time_limit() const;
  void clear_sms_time_limit();
  static const int kSmsTimeLimitFieldNumber = 4;
  ::google::protobuf::int32 sms_time_limit() const;
  void set_sms_time_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GateServerConfigInfo)
 private:
  void set_has_gate_id();
  void clear_has_gate_id();
  void set_has_port();
  void clear_has_port();
  void set_has_timeout_limit();
  void clear_has_timeout_limit();
  void set_has_sms_time_limit();
  void clear_has_sms_time_limit();
  void set_has_sms_url();
  void clear_has_sms_url();
  void set_has_sms_sign_key();
  void clear_has_sms_sign_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress > login_addr_;
  ::google::protobuf::RepeatedPtrField< ::NetworkAddress > game_addr_;
  ::google::protobuf::internal::ArenaStringPtr sms_url_;
  ::google::protobuf::internal::ArenaStringPtr sms_sign_key_;
  ::google::protobuf::int32 gate_id_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 timeout_limit_;
  ::google::protobuf::int32 sms_time_limit_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DBServerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DBServerConfig) */ {
 public:
  DBServerConfig();
  virtual ~DBServerConfig();

  DBServerConfig(const DBServerConfig& from);

  inline DBServerConfig& operator=(const DBServerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBServerConfig& default_instance();

  static inline const DBServerConfig* internal_default_instance() {
    return reinterpret_cast<const DBServerConfig*>(
               &_DBServerConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DBServerConfig* other);

  // implements Message ----------------------------------------------

  inline DBServerConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  DBServerConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DBServerConfig& from);
  void MergeFrom(const DBServerConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DBServerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RedisSentinelOption def_sentinel = 8;
  int def_sentinel_size() const;
  void clear_def_sentinel();
  static const int kDefSentinelFieldNumber = 8;
  const ::RedisSentinelOption& def_sentinel(int index) const;
  ::RedisSentinelOption* mutable_def_sentinel(int index);
  ::RedisSentinelOption* add_def_sentinel();
  ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >*
      mutable_def_sentinel();
  const ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >&
      def_sentinel() const;

  // optional string php_sign_key = 10;
  bool has_php_sign_key() const;
  void clear_php_sign_key();
  static const int kPhpSignKeyFieldNumber = 10;
  const ::std::string& php_sign_key() const;
  void set_php_sign_key(const ::std::string& value);
  #if LANG_CXX11
  void set_php_sign_key(::std::string&& value);
  #endif
  void set_php_sign_key(const char* value);
  void set_php_sign_key(const char* value, size_t size);
  ::std::string* mutable_php_sign_key();
  ::std::string* release_php_sign_key();
  void set_allocated_php_sign_key(::std::string* php_sign_key);

  // optional string php_interface_addr = 12;
  bool has_php_interface_addr() const;
  void clear_php_interface_addr();
  static const int kPhpInterfaceAddrFieldNumber = 12;
  const ::std::string& php_interface_addr() const;
  void set_php_interface_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_php_interface_addr(::std::string&& value);
  #endif
  void set_php_interface_addr(const char* value);
  void set_php_interface_addr(const char* value, size_t size);
  ::std::string* mutable_php_interface_addr();
  ::std::string* release_php_interface_addr();
  void set_allocated_php_interface_addr(::std::string* php_interface_addr);

  // optional string cash_money_addr = 13;
  bool has_cash_money_addr() const;
  void clear_cash_money_addr();
  static const int kCashMoneyAddrFieldNumber = 13;
  const ::std::string& cash_money_addr() const;
  void set_cash_money_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_cash_money_addr(::std::string&& value);
  #endif
  void set_cash_money_addr(const char* value);
  void set_cash_money_addr(const char* value, size_t size);
  ::std::string* mutable_cash_money_addr();
  ::std::string* release_cash_money_addr();
  void set_allocated_cash_money_addr(::std::string* cash_money_addr);

  // required .DBConnectOption login_db = 2;
  bool has_login_db() const;
  void clear_login_db();
  static const int kLoginDbFieldNumber = 2;
  const ::DBConnectOption& login_db() const;
  ::DBConnectOption* mutable_login_db();
  ::DBConnectOption* release_login_db();
  void set_allocated_login_db(::DBConnectOption* login_db);

  // required .DBConnectOption game_db = 3;
  bool has_game_db() const;
  void clear_game_db();
  static const int kGameDbFieldNumber = 3;
  const ::DBConnectOption& game_db() const;
  ::DBConnectOption* mutable_game_db();
  ::DBConnectOption* release_game_db();
  void set_allocated_game_db(::DBConnectOption* game_db);

  // required .DBConnectOption log_db = 4;
  bool has_log_db() const;
  void clear_log_db();
  static const int kLogDbFieldNumber = 4;
  const ::DBConnectOption& log_db() const;
  ::DBConnectOption* mutable_log_db();
  ::DBConnectOption* release_log_db();
  void set_allocated_log_db(::DBConnectOption* log_db);

  // required .DBConnectOption recharge_db = 5;
  bool has_recharge_db() const;
  void clear_recharge_db();
  static const int kRechargeDbFieldNumber = 5;
  const ::DBConnectOption& recharge_db() const;
  ::DBConnectOption* mutable_recharge_db();
  ::DBConnectOption* release_recharge_db();
  void set_allocated_recharge_db(::DBConnectOption* recharge_db);

  // optional .RedisConnectOption def_redis = 7;
  bool has_def_redis() const;
  void clear_def_redis();
  static const int kDefRedisFieldNumber = 7;
  const ::RedisConnectOption& def_redis() const;
  ::RedisConnectOption* mutable_def_redis();
  ::RedisConnectOption* release_def_redis();
  void set_allocated_def_redis(::RedisConnectOption* def_redis);

  // required int32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional int32 init_money = 9;
  bool has_init_money() const;
  void clear_init_money();
  static const int kInitMoneyFieldNumber = 9;
  ::google::protobuf::int32 init_money() const;
  void set_init_money(::google::protobuf::int32 value);

  // optional int32 bank_transfer_tax = 11;
  bool has_bank_transfer_tax() const;
  void clear_bank_transfer_tax();
  static const int kBankTransferTaxFieldNumber = 11;
  ::google::protobuf::int32 bank_transfer_tax() const;
  void set_bank_transfer_tax(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DBServerConfig)
 private:
  void set_has_port();
  void clear_has_port();
  void set_has_login_db();
  void clear_has_login_db();
  void set_has_game_db();
  void clear_has_game_db();
  void set_has_log_db();
  void clear_has_log_db();
  void set_has_recharge_db();
  void clear_has_recharge_db();
  void set_has_def_redis();
  void clear_has_def_redis();
  void set_has_init_money();
  void clear_has_init_money();
  void set_has_php_sign_key();
  void clear_has_php_sign_key();
  void set_has_bank_transfer_tax();
  void clear_has_bank_transfer_tax();
  void set_has_php_interface_addr();
  void clear_has_php_interface_addr();
  void set_has_cash_money_addr();
  void clear_has_cash_money_addr();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption > def_sentinel_;
  ::google::protobuf::internal::ArenaStringPtr php_sign_key_;
  ::google::protobuf::internal::ArenaStringPtr php_interface_addr_;
  ::google::protobuf::internal::ArenaStringPtr cash_money_addr_;
  ::DBConnectOption* login_db_;
  ::DBConnectOption* game_db_;
  ::DBConnectOption* log_db_;
  ::DBConnectOption* recharge_db_;
  ::RedisConnectOption* def_redis_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 init_money_;
  ::google::protobuf::int32 bank_transfer_tax_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrivateRoomInfoConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PrivateRoomInfoConfig) */ {
 public:
  PrivateRoomInfoConfig();
  virtual ~PrivateRoomInfoConfig();

  PrivateRoomInfoConfig(const PrivateRoomInfoConfig& from);

  inline PrivateRoomInfoConfig& operator=(const PrivateRoomInfoConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateRoomInfoConfig& default_instance();

  static inline const PrivateRoomInfoConfig* internal_default_instance() {
    return reinterpret_cast<const PrivateRoomInfoConfig*>(
               &_PrivateRoomInfoConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PrivateRoomInfoConfig* other);

  // implements Message ----------------------------------------------

  inline PrivateRoomInfoConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PrivateRoomInfoConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PrivateRoomInfoConfig& from);
  void MergeFrom(const PrivateRoomInfoConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PrivateRoomInfoConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string room_lua_cfg = 3;
  bool has_room_lua_cfg() const;
  void clear_room_lua_cfg();
  static const int kRoomLuaCfgFieldNumber = 3;
  const ::std::string& room_lua_cfg() const;
  void set_room_lua_cfg(const ::std::string& value);
  #if LANG_CXX11
  void set_room_lua_cfg(::std::string&& value);
  #endif
  void set_room_lua_cfg(const char* value);
  void set_room_lua_cfg(const char* value, size_t size);
  ::std::string* mutable_room_lua_cfg();
  ::std::string* release_room_lua_cfg();
  void set_allocated_room_lua_cfg(::std::string* room_lua_cfg);

  // optional int32 game_id = 1;
  bool has_game_id() const;
  void clear_game_id();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::int32 game_id() const;
  void set_game_id(::google::protobuf::int32 value);

  // optional int32 first_game_type = 2;
  bool has_first_game_type() const;
  void clear_first_game_type();
  static const int kFirstGameTypeFieldNumber = 2;
  ::google::protobuf::int32 first_game_type() const;
  void set_first_game_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PrivateRoomInfoConfig)
 private:
  void set_has_game_id();
  void clear_has_game_id();
  void set_has_first_game_type();
  void clear_has_first_game_type();
  void set_has_room_lua_cfg();
  void clear_has_room_lua_cfg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr room_lua_cfg_;
  ::google::protobuf::int32 game_id_;
  ::google::protobuf::int32 first_game_type_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrivateRoomListConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PrivateRoomListConfig) */ {
 public:
  PrivateRoomListConfig();
  virtual ~PrivateRoomListConfig();

  PrivateRoomListConfig(const PrivateRoomListConfig& from);

  inline PrivateRoomListConfig& operator=(const PrivateRoomListConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateRoomListConfig& default_instance();

  static inline const PrivateRoomListConfig* internal_default_instance() {
    return reinterpret_cast<const PrivateRoomListConfig*>(
               &_PrivateRoomListConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(PrivateRoomListConfig* other);

  // implements Message ----------------------------------------------

  inline PrivateRoomListConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PrivateRoomListConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PrivateRoomListConfig& from);
  void MergeFrom(const PrivateRoomListConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PrivateRoomListConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PrivateRoomInfoConfig info = 1;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::PrivateRoomInfoConfig& info(int index) const;
  ::PrivateRoomInfoConfig* mutable_info(int index);
  ::PrivateRoomInfoConfig* add_info();
  ::google::protobuf::RepeatedPtrField< ::PrivateRoomInfoConfig >*
      mutable_info();
  const ::google::protobuf::RepeatedPtrField< ::PrivateRoomInfoConfig >&
      info() const;

  // @@protoc_insertion_point(class_scope:PrivateRoomListConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PrivateRoomInfoConfig > info_;
  friend struct protobuf_config_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// NetworkAddress

// required string ip = 1;
inline bool NetworkAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkAddress::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& NetworkAddress::ip() const {
  // @@protoc_insertion_point(field_get:NetworkAddress.ip)
  return ip_.GetNoArena();
}
inline void NetworkAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkAddress.ip)
}
#if LANG_CXX11
inline void NetworkAddress::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NetworkAddress.ip)
}
#endif
inline void NetworkAddress::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkAddress.ip)
}
inline void NetworkAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkAddress.ip)
}
inline ::std::string* NetworkAddress::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:NetworkAddress.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkAddress::release_ip() {
  // @@protoc_insertion_point(field_release:NetworkAddress.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkAddress::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:NetworkAddress.ip)
}

// required int32 port = 2;
inline bool NetworkAddress::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkAddress::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkAddress::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 NetworkAddress::port() const {
  // @@protoc_insertion_point(field_get:NetworkAddress.port)
  return port_;
}
inline void NetworkAddress::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:NetworkAddress.port)
}

// optional int32 server_id = 3;
inline bool NetworkAddress::has_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkAddress::set_has_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkAddress::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkAddress::clear_server_id() {
  server_id_ = 0;
  clear_has_server_id();
}
inline ::google::protobuf::int32 NetworkAddress::server_id() const {
  // @@protoc_insertion_point(field_get:NetworkAddress.server_id)
  return server_id_;
}
inline void NetworkAddress::set_server_id(::google::protobuf::int32 value) {
  set_has_server_id();
  server_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkAddress.server_id)
}

// -------------------------------------------------------------------

// DBConnectOption

// required string host = 1;
inline bool DBConnectOption::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBConnectOption::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBConnectOption::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBConnectOption::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& DBConnectOption::host() const {
  // @@protoc_insertion_point(field_get:DBConnectOption.host)
  return host_.GetNoArena();
}
inline void DBConnectOption::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DBConnectOption.host)
}
#if LANG_CXX11
inline void DBConnectOption::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DBConnectOption.host)
}
#endif
inline void DBConnectOption::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DBConnectOption.host)
}
inline void DBConnectOption::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DBConnectOption.host)
}
inline ::std::string* DBConnectOption::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:DBConnectOption.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBConnectOption::release_host() {
  // @@protoc_insertion_point(field_release:DBConnectOption.host)
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBConnectOption::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:DBConnectOption.host)
}

// required string user = 2;
inline bool DBConnectOption::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBConnectOption::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBConnectOption::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBConnectOption::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& DBConnectOption::user() const {
  // @@protoc_insertion_point(field_get:DBConnectOption.user)
  return user_.GetNoArena();
}
inline void DBConnectOption::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DBConnectOption.user)
}
#if LANG_CXX11
inline void DBConnectOption::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DBConnectOption.user)
}
#endif
inline void DBConnectOption::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DBConnectOption.user)
}
inline void DBConnectOption::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DBConnectOption.user)
}
inline ::std::string* DBConnectOption::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:DBConnectOption.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBConnectOption::release_user() {
  // @@protoc_insertion_point(field_release:DBConnectOption.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBConnectOption::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:DBConnectOption.user)
}

// required string password = 3;
inline bool DBConnectOption::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBConnectOption::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBConnectOption::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBConnectOption::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& DBConnectOption::password() const {
  // @@protoc_insertion_point(field_get:DBConnectOption.password)
  return password_.GetNoArena();
}
inline void DBConnectOption::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DBConnectOption.password)
}
#if LANG_CXX11
inline void DBConnectOption::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DBConnectOption.password)
}
#endif
inline void DBConnectOption::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DBConnectOption.password)
}
inline void DBConnectOption::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DBConnectOption.password)
}
inline ::std::string* DBConnectOption::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:DBConnectOption.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBConnectOption::release_password() {
  // @@protoc_insertion_point(field_release:DBConnectOption.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBConnectOption::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:DBConnectOption.password)
}

// required string database = 4;
inline bool DBConnectOption::has_database() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBConnectOption::set_has_database() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBConnectOption::clear_has_database() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBConnectOption::clear_database() {
  database_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_database();
}
inline const ::std::string& DBConnectOption::database() const {
  // @@protoc_insertion_point(field_get:DBConnectOption.database)
  return database_.GetNoArena();
}
inline void DBConnectOption::set_database(const ::std::string& value) {
  set_has_database();
  database_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DBConnectOption.database)
}
#if LANG_CXX11
inline void DBConnectOption::set_database(::std::string&& value) {
  set_has_database();
  database_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DBConnectOption.database)
}
#endif
inline void DBConnectOption::set_database(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_database();
  database_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DBConnectOption.database)
}
inline void DBConnectOption::set_database(const char* value, size_t size) {
  set_has_database();
  database_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DBConnectOption.database)
}
inline ::std::string* DBConnectOption::mutable_database() {
  set_has_database();
  // @@protoc_insertion_point(field_mutable:DBConnectOption.database)
  return database_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBConnectOption::release_database() {
  // @@protoc_insertion_point(field_release:DBConnectOption.database)
  clear_has_database();
  return database_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBConnectOption::set_allocated_database(::std::string* database) {
  if (database != NULL) {
    set_has_database();
  } else {
    clear_has_database();
  }
  database_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), database);
  // @@protoc_insertion_point(field_set_allocated:DBConnectOption.database)
}

// -------------------------------------------------------------------

// RedisConnectOption

// required string ip = 1;
inline bool RedisConnectOption::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedisConnectOption::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedisConnectOption::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedisConnectOption::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& RedisConnectOption::ip() const {
  // @@protoc_insertion_point(field_get:RedisConnectOption.ip)
  return ip_.GetNoArena();
}
inline void RedisConnectOption::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RedisConnectOption.ip)
}
#if LANG_CXX11
inline void RedisConnectOption::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RedisConnectOption.ip)
}
#endif
inline void RedisConnectOption::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RedisConnectOption.ip)
}
inline void RedisConnectOption::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RedisConnectOption.ip)
}
inline ::std::string* RedisConnectOption::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:RedisConnectOption.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisConnectOption::release_ip() {
  // @@protoc_insertion_point(field_release:RedisConnectOption.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisConnectOption::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:RedisConnectOption.ip)
}

// required int32 port = 2;
inline bool RedisConnectOption::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedisConnectOption::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedisConnectOption::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedisConnectOption::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RedisConnectOption::port() const {
  // @@protoc_insertion_point(field_get:RedisConnectOption.port)
  return port_;
}
inline void RedisConnectOption::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:RedisConnectOption.port)
}

// optional int32 dbnum = 3;
inline bool RedisConnectOption::has_dbnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedisConnectOption::set_has_dbnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedisConnectOption::clear_has_dbnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedisConnectOption::clear_dbnum() {
  dbnum_ = 0;
  clear_has_dbnum();
}
inline ::google::protobuf::int32 RedisConnectOption::dbnum() const {
  // @@protoc_insertion_point(field_get:RedisConnectOption.dbnum)
  return dbnum_;
}
inline void RedisConnectOption::set_dbnum(::google::protobuf::int32 value) {
  set_has_dbnum();
  dbnum_ = value;
  // @@protoc_insertion_point(field_set:RedisConnectOption.dbnum)
}

// optional string password = 4;
inline bool RedisConnectOption::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedisConnectOption::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedisConnectOption::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedisConnectOption::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& RedisConnectOption::password() const {
  // @@protoc_insertion_point(field_get:RedisConnectOption.password)
  return password_.GetNoArena();
}
inline void RedisConnectOption::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RedisConnectOption.password)
}
#if LANG_CXX11
inline void RedisConnectOption::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RedisConnectOption.password)
}
#endif
inline void RedisConnectOption::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RedisConnectOption.password)
}
inline void RedisConnectOption::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RedisConnectOption.password)
}
inline ::std::string* RedisConnectOption::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:RedisConnectOption.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisConnectOption::release_password() {
  // @@protoc_insertion_point(field_release:RedisConnectOption.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisConnectOption::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:RedisConnectOption.password)
}

// -------------------------------------------------------------------

// RedisSentinelOption

// required string ip = 1;
inline bool RedisSentinelOption::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedisSentinelOption::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedisSentinelOption::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedisSentinelOption::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& RedisSentinelOption::ip() const {
  // @@protoc_insertion_point(field_get:RedisSentinelOption.ip)
  return ip_.GetNoArena();
}
inline void RedisSentinelOption::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RedisSentinelOption.ip)
}
#if LANG_CXX11
inline void RedisSentinelOption::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RedisSentinelOption.ip)
}
#endif
inline void RedisSentinelOption::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RedisSentinelOption.ip)
}
inline void RedisSentinelOption::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RedisSentinelOption.ip)
}
inline ::std::string* RedisSentinelOption::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:RedisSentinelOption.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisSentinelOption::release_ip() {
  // @@protoc_insertion_point(field_release:RedisSentinelOption.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisSentinelOption::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:RedisSentinelOption.ip)
}

// required int32 port = 2;
inline bool RedisSentinelOption::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedisSentinelOption::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedisSentinelOption::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedisSentinelOption::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RedisSentinelOption::port() const {
  // @@protoc_insertion_point(field_get:RedisSentinelOption.port)
  return port_;
}
inline void RedisSentinelOption::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:RedisSentinelOption.port)
}

// optional int32 dbnum = 3;
inline bool RedisSentinelOption::has_dbnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RedisSentinelOption::set_has_dbnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RedisSentinelOption::clear_has_dbnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RedisSentinelOption::clear_dbnum() {
  dbnum_ = 0;
  clear_has_dbnum();
}
inline ::google::protobuf::int32 RedisSentinelOption::dbnum() const {
  // @@protoc_insertion_point(field_get:RedisSentinelOption.dbnum)
  return dbnum_;
}
inline void RedisSentinelOption::set_dbnum(::google::protobuf::int32 value) {
  set_has_dbnum();
  dbnum_ = value;
  // @@protoc_insertion_point(field_set:RedisSentinelOption.dbnum)
}

// required string master_name = 4;
inline bool RedisSentinelOption::has_master_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedisSentinelOption::set_has_master_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedisSentinelOption::clear_has_master_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedisSentinelOption::clear_master_name() {
  master_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_master_name();
}
inline const ::std::string& RedisSentinelOption::master_name() const {
  // @@protoc_insertion_point(field_get:RedisSentinelOption.master_name)
  return master_name_.GetNoArena();
}
inline void RedisSentinelOption::set_master_name(const ::std::string& value) {
  set_has_master_name();
  master_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RedisSentinelOption.master_name)
}
#if LANG_CXX11
inline void RedisSentinelOption::set_master_name(::std::string&& value) {
  set_has_master_name();
  master_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RedisSentinelOption.master_name)
}
#endif
inline void RedisSentinelOption::set_master_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_master_name();
  master_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RedisSentinelOption.master_name)
}
inline void RedisSentinelOption::set_master_name(const char* value, size_t size) {
  set_has_master_name();
  master_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RedisSentinelOption.master_name)
}
inline ::std::string* RedisSentinelOption::mutable_master_name() {
  set_has_master_name();
  // @@protoc_insertion_point(field_mutable:RedisSentinelOption.master_name)
  return master_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisSentinelOption::release_master_name() {
  // @@protoc_insertion_point(field_release:RedisSentinelOption.master_name)
  clear_has_master_name();
  return master_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisSentinelOption::set_allocated_master_name(::std::string* master_name) {
  if (master_name != NULL) {
    set_has_master_name();
  } else {
    clear_has_master_name();
  }
  master_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), master_name);
  // @@protoc_insertion_point(field_set_allocated:RedisSentinelOption.master_name)
}

// optional string password = 5;
inline bool RedisSentinelOption::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedisSentinelOption::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedisSentinelOption::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedisSentinelOption::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& RedisSentinelOption::password() const {
  // @@protoc_insertion_point(field_get:RedisSentinelOption.password)
  return password_.GetNoArena();
}
inline void RedisSentinelOption::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RedisSentinelOption.password)
}
#if LANG_CXX11
inline void RedisSentinelOption::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RedisSentinelOption.password)
}
#endif
inline void RedisSentinelOption::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RedisSentinelOption.password)
}
inline void RedisSentinelOption::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RedisSentinelOption.password)
}
inline ::std::string* RedisSentinelOption::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:RedisSentinelOption.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedisSentinelOption::release_password() {
  // @@protoc_insertion_point(field_release:RedisSentinelOption.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedisSentinelOption::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:RedisSentinelOption.password)
}

// -------------------------------------------------------------------

// ConfigServer_Config

// required int32 port = 1;
inline bool ConfigServer_Config::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigServer_Config::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigServer_Config::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigServer_Config::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ConfigServer_Config::port() const {
  // @@protoc_insertion_point(field_get:ConfigServer_Config.port)
  return port_;
}
inline void ConfigServer_Config::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:ConfigServer_Config.port)
}

// required .DBConnectOption config_db = 2;
inline bool ConfigServer_Config::has_config_db() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigServer_Config::set_has_config_db() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigServer_Config::clear_has_config_db() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigServer_Config::clear_config_db() {
  if (config_db_ != NULL) config_db_->::DBConnectOption::Clear();
  clear_has_config_db();
}
inline const ::DBConnectOption& ConfigServer_Config::config_db() const {
  // @@protoc_insertion_point(field_get:ConfigServer_Config.config_db)
  return config_db_ != NULL ? *config_db_
                         : *::DBConnectOption::internal_default_instance();
}
inline ::DBConnectOption* ConfigServer_Config::mutable_config_db() {
  set_has_config_db();
  if (config_db_ == NULL) {
    config_db_ = new ::DBConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:ConfigServer_Config.config_db)
  return config_db_;
}
inline ::DBConnectOption* ConfigServer_Config::release_config_db() {
  // @@protoc_insertion_point(field_release:ConfigServer_Config.config_db)
  clear_has_config_db();
  ::DBConnectOption* temp = config_db_;
  config_db_ = NULL;
  return temp;
}
inline void ConfigServer_Config::set_allocated_config_db(::DBConnectOption* config_db) {
  delete config_db_;
  config_db_ = config_db;
  if (config_db) {
    set_has_config_db();
  } else {
    clear_has_config_db();
  }
  // @@protoc_insertion_point(field_set_allocated:ConfigServer_Config.config_db)
}

// required .DBConnectOption config_game = 3;
inline bool ConfigServer_Config::has_config_game() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigServer_Config::set_has_config_game() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigServer_Config::clear_has_config_game() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigServer_Config::clear_config_game() {
  if (config_game_ != NULL) config_game_->::DBConnectOption::Clear();
  clear_has_config_game();
}
inline const ::DBConnectOption& ConfigServer_Config::config_game() const {
  // @@protoc_insertion_point(field_get:ConfigServer_Config.config_game)
  return config_game_ != NULL ? *config_game_
                         : *::DBConnectOption::internal_default_instance();
}
inline ::DBConnectOption* ConfigServer_Config::mutable_config_game() {
  set_has_config_game();
  if (config_game_ == NULL) {
    config_game_ = new ::DBConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:ConfigServer_Config.config_game)
  return config_game_;
}
inline ::DBConnectOption* ConfigServer_Config::release_config_game() {
  // @@protoc_insertion_point(field_release:ConfigServer_Config.config_game)
  clear_has_config_game();
  ::DBConnectOption* temp = config_game_;
  config_game_ = NULL;
  return temp;
}
inline void ConfigServer_Config::set_allocated_config_game(::DBConnectOption* config_game) {
  delete config_game_;
  config_game_ = config_game;
  if (config_game) {
    set_has_config_game();
  } else {
    clear_has_config_game();
  }
  // @@protoc_insertion_point(field_set_allocated:ConfigServer_Config.config_game)
}

// optional bool log_print_open = 4;
inline bool ConfigServer_Config::has_log_print_open() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConfigServer_Config::set_has_log_print_open() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConfigServer_Config::clear_has_log_print_open() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConfigServer_Config::clear_log_print_open() {
  log_print_open_ = false;
  clear_has_log_print_open();
}
inline bool ConfigServer_Config::log_print_open() const {
  // @@protoc_insertion_point(field_get:ConfigServer_Config.log_print_open)
  return log_print_open_;
}
inline void ConfigServer_Config::set_log_print_open(bool value) {
  set_has_log_print_open();
  log_print_open_ = value;
  // @@protoc_insertion_point(field_set:ConfigServer_Config.log_print_open)
}

// -------------------------------------------------------------------

// CommonServer_Config

// required .NetworkAddress config_addr = 1;
inline bool CommonServer_Config::has_config_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonServer_Config::set_has_config_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonServer_Config::clear_has_config_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonServer_Config::clear_config_addr() {
  if (config_addr_ != NULL) config_addr_->::NetworkAddress::Clear();
  clear_has_config_addr();
}
inline const ::NetworkAddress& CommonServer_Config::config_addr() const {
  // @@protoc_insertion_point(field_get:CommonServer_Config.config_addr)
  return config_addr_ != NULL ? *config_addr_
                         : *::NetworkAddress::internal_default_instance();
}
inline ::NetworkAddress* CommonServer_Config::mutable_config_addr() {
  set_has_config_addr();
  if (config_addr_ == NULL) {
    config_addr_ = new ::NetworkAddress;
  }
  // @@protoc_insertion_point(field_mutable:CommonServer_Config.config_addr)
  return config_addr_;
}
inline ::NetworkAddress* CommonServer_Config::release_config_addr() {
  // @@protoc_insertion_point(field_release:CommonServer_Config.config_addr)
  clear_has_config_addr();
  ::NetworkAddress* temp = config_addr_;
  config_addr_ = NULL;
  return temp;
}
inline void CommonServer_Config::set_allocated_config_addr(::NetworkAddress* config_addr) {
  delete config_addr_;
  config_addr_ = config_addr;
  if (config_addr) {
    set_has_config_addr();
  } else {
    clear_has_config_addr();
  }
  // @@protoc_insertion_point(field_set_allocated:CommonServer_Config.config_addr)
}

// optional bool log_print_open = 2;
inline bool CommonServer_Config::has_log_print_open() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonServer_Config::set_has_log_print_open() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonServer_Config::clear_has_log_print_open() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonServer_Config::clear_log_print_open() {
  log_print_open_ = false;
  clear_has_log_print_open();
}
inline bool CommonServer_Config::log_print_open() const {
  // @@protoc_insertion_point(field_get:CommonServer_Config.log_print_open)
  return log_print_open_;
}
inline void CommonServer_Config::set_log_print_open(bool value) {
  set_has_log_print_open();
  log_print_open_ = value;
  // @@protoc_insertion_point(field_set:CommonServer_Config.log_print_open)
}

// -------------------------------------------------------------------

// LoginServerConfigInfo

// required int32 login_id = 1;
inline bool LoginServerConfigInfo::has_login_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginServerConfigInfo::set_has_login_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginServerConfigInfo::clear_has_login_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginServerConfigInfo::clear_login_id() {
  login_id_ = 0;
  clear_has_login_id();
}
inline ::google::protobuf::int32 LoginServerConfigInfo::login_id() const {
  // @@protoc_insertion_point(field_get:LoginServerConfigInfo.login_id)
  return login_id_;
}
inline void LoginServerConfigInfo::set_login_id(::google::protobuf::int32 value) {
  set_has_login_id();
  login_id_ = value;
  // @@protoc_insertion_point(field_set:LoginServerConfigInfo.login_id)
}

// required int32 port = 2;
inline bool LoginServerConfigInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginServerConfigInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginServerConfigInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginServerConfigInfo::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 LoginServerConfigInfo::port() const {
  // @@protoc_insertion_point(field_get:LoginServerConfigInfo.port)
  return port_;
}
inline void LoginServerConfigInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:LoginServerConfigInfo.port)
}

// repeated .NetworkAddress db_addr = 3;
inline int LoginServerConfigInfo::db_addr_size() const {
  return db_addr_.size();
}
inline void LoginServerConfigInfo::clear_db_addr() {
  db_addr_.Clear();
}
inline const ::NetworkAddress& LoginServerConfigInfo::db_addr(int index) const {
  // @@protoc_insertion_point(field_get:LoginServerConfigInfo.db_addr)
  return db_addr_.Get(index);
}
inline ::NetworkAddress* LoginServerConfigInfo::mutable_db_addr(int index) {
  // @@protoc_insertion_point(field_mutable:LoginServerConfigInfo.db_addr)
  return db_addr_.Mutable(index);
}
inline ::NetworkAddress* LoginServerConfigInfo::add_db_addr() {
  // @@protoc_insertion_point(field_add:LoginServerConfigInfo.db_addr)
  return db_addr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
LoginServerConfigInfo::mutable_db_addr() {
  // @@protoc_insertion_point(field_mutable_list:LoginServerConfigInfo.db_addr)
  return &db_addr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
LoginServerConfigInfo::db_addr() const {
  // @@protoc_insertion_point(field_list:LoginServerConfigInfo.db_addr)
  return db_addr_;
}

// optional .RedisConnectOption def_redis = 4;
inline bool LoginServerConfigInfo::has_def_redis() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginServerConfigInfo::set_has_def_redis() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginServerConfigInfo::clear_has_def_redis() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginServerConfigInfo::clear_def_redis() {
  if (def_redis_ != NULL) def_redis_->::RedisConnectOption::Clear();
  clear_has_def_redis();
}
inline const ::RedisConnectOption& LoginServerConfigInfo::def_redis() const {
  // @@protoc_insertion_point(field_get:LoginServerConfigInfo.def_redis)
  return def_redis_ != NULL ? *def_redis_
                         : *::RedisConnectOption::internal_default_instance();
}
inline ::RedisConnectOption* LoginServerConfigInfo::mutable_def_redis() {
  set_has_def_redis();
  if (def_redis_ == NULL) {
    def_redis_ = new ::RedisConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:LoginServerConfigInfo.def_redis)
  return def_redis_;
}
inline ::RedisConnectOption* LoginServerConfigInfo::release_def_redis() {
  // @@protoc_insertion_point(field_release:LoginServerConfigInfo.def_redis)
  clear_has_def_redis();
  ::RedisConnectOption* temp = def_redis_;
  def_redis_ = NULL;
  return temp;
}
inline void LoginServerConfigInfo::set_allocated_def_redis(::RedisConnectOption* def_redis) {
  delete def_redis_;
  def_redis_ = def_redis;
  if (def_redis) {
    set_has_def_redis();
  } else {
    clear_has_def_redis();
  }
  // @@protoc_insertion_point(field_set_allocated:LoginServerConfigInfo.def_redis)
}

// repeated .RedisSentinelOption def_sentinel = 5;
inline int LoginServerConfigInfo::def_sentinel_size() const {
  return def_sentinel_.size();
}
inline void LoginServerConfigInfo::clear_def_sentinel() {
  def_sentinel_.Clear();
}
inline const ::RedisSentinelOption& LoginServerConfigInfo::def_sentinel(int index) const {
  // @@protoc_insertion_point(field_get:LoginServerConfigInfo.def_sentinel)
  return def_sentinel_.Get(index);
}
inline ::RedisSentinelOption* LoginServerConfigInfo::mutable_def_sentinel(int index) {
  // @@protoc_insertion_point(field_mutable:LoginServerConfigInfo.def_sentinel)
  return def_sentinel_.Mutable(index);
}
inline ::RedisSentinelOption* LoginServerConfigInfo::add_def_sentinel() {
  // @@protoc_insertion_point(field_add:LoginServerConfigInfo.def_sentinel)
  return def_sentinel_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >*
LoginServerConfigInfo::mutable_def_sentinel() {
  // @@protoc_insertion_point(field_mutable_list:LoginServerConfigInfo.def_sentinel)
  return &def_sentinel_;
}
inline const ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >&
LoginServerConfigInfo::def_sentinel() const {
  // @@protoc_insertion_point(field_list:LoginServerConfigInfo.def_sentinel)
  return def_sentinel_;
}

// -------------------------------------------------------------------

// GameServerConfigInfo

// required int32 game_id = 1;
inline bool GameServerConfigInfo::has_game_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameServerConfigInfo::set_has_game_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameServerConfigInfo::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameServerConfigInfo::clear_game_id() {
  game_id_ = 0;
  clear_has_game_id();
}
inline ::google::protobuf::int32 GameServerConfigInfo::game_id() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.game_id)
  return game_id_;
}
inline void GameServerConfigInfo::set_game_id(::google::protobuf::int32 value) {
  set_has_game_id();
  game_id_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.game_id)
}

// required int32 port = 2;
inline bool GameServerConfigInfo::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameServerConfigInfo::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameServerConfigInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameServerConfigInfo::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 GameServerConfigInfo::port() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.port)
  return port_;
}
inline void GameServerConfigInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.port)
}

// optional int32 using_login_validatebox = 3;
inline bool GameServerConfigInfo::has_using_login_validatebox() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameServerConfigInfo::set_has_using_login_validatebox() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameServerConfigInfo::clear_has_using_login_validatebox() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameServerConfigInfo::clear_using_login_validatebox() {
  using_login_validatebox_ = 0;
  clear_has_using_login_validatebox();
}
inline ::google::protobuf::int32 GameServerConfigInfo::using_login_validatebox() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.using_login_validatebox)
  return using_login_validatebox_;
}
inline void GameServerConfigInfo::set_using_login_validatebox(::google::protobuf::int32 value) {
  set_has_using_login_validatebox();
  using_login_validatebox_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.using_login_validatebox)
}

// optional int32 default_lobby = 4;
inline bool GameServerConfigInfo::has_default_lobby() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameServerConfigInfo::set_has_default_lobby() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameServerConfigInfo::clear_has_default_lobby() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameServerConfigInfo::clear_default_lobby() {
  default_lobby_ = 0;
  clear_has_default_lobby();
}
inline ::google::protobuf::int32 GameServerConfigInfo::default_lobby() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.default_lobby)
  return default_lobby_;
}
inline void GameServerConfigInfo::set_default_lobby(::google::protobuf::int32 value) {
  set_has_default_lobby();
  default_lobby_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.default_lobby)
}

// optional int32 first_game_type = 5;
inline bool GameServerConfigInfo::has_first_game_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameServerConfigInfo::set_has_first_game_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameServerConfigInfo::clear_has_first_game_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameServerConfigInfo::clear_first_game_type() {
  first_game_type_ = 0;
  clear_has_first_game_type();
}
inline ::google::protobuf::int32 GameServerConfigInfo::first_game_type() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.first_game_type)
  return first_game_type_;
}
inline void GameServerConfigInfo::set_first_game_type(::google::protobuf::int32 value) {
  set_has_first_game_type();
  first_game_type_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.first_game_type)
}

// optional int32 second_game_type = 6;
inline bool GameServerConfigInfo::has_second_game_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameServerConfigInfo::set_has_second_game_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameServerConfigInfo::clear_has_second_game_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameServerConfigInfo::clear_second_game_type() {
  second_game_type_ = 0;
  clear_has_second_game_type();
}
inline ::google::protobuf::int32 GameServerConfigInfo::second_game_type() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.second_game_type)
  return second_game_type_;
}
inline void GameServerConfigInfo::set_second_game_type(::google::protobuf::int32 value) {
  set_has_second_game_type();
  second_game_type_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.second_game_type)
}

// optional int32 player_limit = 7;
inline bool GameServerConfigInfo::has_player_limit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameServerConfigInfo::set_has_player_limit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameServerConfigInfo::clear_has_player_limit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameServerConfigInfo::clear_player_limit() {
  player_limit_ = 0;
  clear_has_player_limit();
}
inline ::google::protobuf::int32 GameServerConfigInfo::player_limit() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.player_limit)
  return player_limit_;
}
inline void GameServerConfigInfo::set_player_limit(::google::protobuf::int32 value) {
  set_has_player_limit();
  player_limit_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.player_limit)
}

// optional int32 table_count = 8;
inline bool GameServerConfigInfo::has_table_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameServerConfigInfo::set_has_table_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameServerConfigInfo::clear_has_table_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameServerConfigInfo::clear_table_count() {
  table_count_ = 0;
  clear_has_table_count();
}
inline ::google::protobuf::int32 GameServerConfigInfo::table_count() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.table_count)
  return table_count_;
}
inline void GameServerConfigInfo::set_table_count(::google::protobuf::int32 value) {
  set_has_table_count();
  table_count_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.table_count)
}

// optional int32 money_limit = 9;
inline bool GameServerConfigInfo::has_money_limit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameServerConfigInfo::set_has_money_limit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameServerConfigInfo::clear_has_money_limit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameServerConfigInfo::clear_money_limit() {
  money_limit_ = 0;
  clear_has_money_limit();
}
inline ::google::protobuf::int32 GameServerConfigInfo::money_limit() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.money_limit)
  return money_limit_;
}
inline void GameServerConfigInfo::set_money_limit(::google::protobuf::int32 value) {
  set_has_money_limit();
  money_limit_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.money_limit)
}

// optional int32 cell_money = 10;
inline bool GameServerConfigInfo::has_cell_money() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameServerConfigInfo::set_has_cell_money() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameServerConfigInfo::clear_has_cell_money() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameServerConfigInfo::clear_cell_money() {
  cell_money_ = 0;
  clear_has_cell_money();
}
inline ::google::protobuf::int32 GameServerConfigInfo::cell_money() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.cell_money)
  return cell_money_;
}
inline void GameServerConfigInfo::set_cell_money(::google::protobuf::int32 value) {
  set_has_cell_money();
  cell_money_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.cell_money)
}

// optional int32 tax_open = 11;
inline bool GameServerConfigInfo::has_tax_open() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameServerConfigInfo::set_has_tax_open() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameServerConfigInfo::clear_has_tax_open() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameServerConfigInfo::clear_tax_open() {
  tax_open_ = 0;
  clear_has_tax_open();
}
inline ::google::protobuf::int32 GameServerConfigInfo::tax_open() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.tax_open)
  return tax_open_;
}
inline void GameServerConfigInfo::set_tax_open(::google::protobuf::int32 value) {
  set_has_tax_open();
  tax_open_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.tax_open)
}

// optional int32 tax_show = 12;
inline bool GameServerConfigInfo::has_tax_show() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameServerConfigInfo::set_has_tax_show() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameServerConfigInfo::clear_has_tax_show() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameServerConfigInfo::clear_tax_show() {
  tax_show_ = 0;
  clear_has_tax_show();
}
inline ::google::protobuf::int32 GameServerConfigInfo::tax_show() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.tax_show)
  return tax_show_;
}
inline void GameServerConfigInfo::set_tax_show(::google::protobuf::int32 value) {
  set_has_tax_show();
  tax_show_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.tax_show)
}

// optional int32 tax = 13;
inline bool GameServerConfigInfo::has_tax() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GameServerConfigInfo::set_has_tax() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GameServerConfigInfo::clear_has_tax() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GameServerConfigInfo::clear_tax() {
  tax_ = 0;
  clear_has_tax();
}
inline ::google::protobuf::int32 GameServerConfigInfo::tax() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.tax)
  return tax_;
}
inline void GameServerConfigInfo::set_tax(::google::protobuf::int32 value) {
  set_has_tax();
  tax_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.tax)
}

// optional string room_lua_cfg = 14;
inline bool GameServerConfigInfo::has_room_lua_cfg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameServerConfigInfo::set_has_room_lua_cfg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameServerConfigInfo::clear_has_room_lua_cfg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameServerConfigInfo::clear_room_lua_cfg() {
  room_lua_cfg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_room_lua_cfg();
}
inline const ::std::string& GameServerConfigInfo::room_lua_cfg() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.room_lua_cfg)
  return room_lua_cfg_.GetNoArena();
}
inline void GameServerConfigInfo::set_room_lua_cfg(const ::std::string& value) {
  set_has_room_lua_cfg();
  room_lua_cfg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.room_lua_cfg)
}
#if LANG_CXX11
inline void GameServerConfigInfo::set_room_lua_cfg(::std::string&& value) {
  set_has_room_lua_cfg();
  room_lua_cfg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GameServerConfigInfo.room_lua_cfg)
}
#endif
inline void GameServerConfigInfo::set_room_lua_cfg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_room_lua_cfg();
  room_lua_cfg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameServerConfigInfo.room_lua_cfg)
}
inline void GameServerConfigInfo::set_room_lua_cfg(const char* value, size_t size) {
  set_has_room_lua_cfg();
  room_lua_cfg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameServerConfigInfo.room_lua_cfg)
}
inline ::std::string* GameServerConfigInfo::mutable_room_lua_cfg() {
  set_has_room_lua_cfg();
  // @@protoc_insertion_point(field_mutable:GameServerConfigInfo.room_lua_cfg)
  return room_lua_cfg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameServerConfigInfo::release_room_lua_cfg() {
  // @@protoc_insertion_point(field_release:GameServerConfigInfo.room_lua_cfg)
  clear_has_room_lua_cfg();
  return room_lua_cfg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameServerConfigInfo::set_allocated_room_lua_cfg(::std::string* room_lua_cfg) {
  if (room_lua_cfg != NULL) {
    set_has_room_lua_cfg();
  } else {
    clear_has_room_lua_cfg();
  }
  room_lua_cfg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), room_lua_cfg);
  // @@protoc_insertion_point(field_set_allocated:GameServerConfigInfo.room_lua_cfg)
}

// repeated .NetworkAddress login_addr = 15;
inline int GameServerConfigInfo::login_addr_size() const {
  return login_addr_.size();
}
inline void GameServerConfigInfo::clear_login_addr() {
  login_addr_.Clear();
}
inline const ::NetworkAddress& GameServerConfigInfo::login_addr(int index) const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.login_addr)
  return login_addr_.Get(index);
}
inline ::NetworkAddress* GameServerConfigInfo::mutable_login_addr(int index) {
  // @@protoc_insertion_point(field_mutable:GameServerConfigInfo.login_addr)
  return login_addr_.Mutable(index);
}
inline ::NetworkAddress* GameServerConfigInfo::add_login_addr() {
  // @@protoc_insertion_point(field_add:GameServerConfigInfo.login_addr)
  return login_addr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
GameServerConfigInfo::mutable_login_addr() {
  // @@protoc_insertion_point(field_mutable_list:GameServerConfigInfo.login_addr)
  return &login_addr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
GameServerConfigInfo::login_addr() const {
  // @@protoc_insertion_point(field_list:GameServerConfigInfo.login_addr)
  return login_addr_;
}

// repeated .NetworkAddress db_addr = 16;
inline int GameServerConfigInfo::db_addr_size() const {
  return db_addr_.size();
}
inline void GameServerConfigInfo::clear_db_addr() {
  db_addr_.Clear();
}
inline const ::NetworkAddress& GameServerConfigInfo::db_addr(int index) const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.db_addr)
  return db_addr_.Get(index);
}
inline ::NetworkAddress* GameServerConfigInfo::mutable_db_addr(int index) {
  // @@protoc_insertion_point(field_mutable:GameServerConfigInfo.db_addr)
  return db_addr_.Mutable(index);
}
inline ::NetworkAddress* GameServerConfigInfo::add_db_addr() {
  // @@protoc_insertion_point(field_add:GameServerConfigInfo.db_addr)
  return db_addr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
GameServerConfigInfo::mutable_db_addr() {
  // @@protoc_insertion_point(field_mutable_list:GameServerConfigInfo.db_addr)
  return &db_addr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
GameServerConfigInfo::db_addr() const {
  // @@protoc_insertion_point(field_list:GameServerConfigInfo.db_addr)
  return db_addr_;
}

// optional .RedisConnectOption def_redis = 17;
inline bool GameServerConfigInfo::has_def_redis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameServerConfigInfo::set_has_def_redis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameServerConfigInfo::clear_has_def_redis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameServerConfigInfo::clear_def_redis() {
  if (def_redis_ != NULL) def_redis_->::RedisConnectOption::Clear();
  clear_has_def_redis();
}
inline const ::RedisConnectOption& GameServerConfigInfo::def_redis() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.def_redis)
  return def_redis_ != NULL ? *def_redis_
                         : *::RedisConnectOption::internal_default_instance();
}
inline ::RedisConnectOption* GameServerConfigInfo::mutable_def_redis() {
  set_has_def_redis();
  if (def_redis_ == NULL) {
    def_redis_ = new ::RedisConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:GameServerConfigInfo.def_redis)
  return def_redis_;
}
inline ::RedisConnectOption* GameServerConfigInfo::release_def_redis() {
  // @@protoc_insertion_point(field_release:GameServerConfigInfo.def_redis)
  clear_has_def_redis();
  ::RedisConnectOption* temp = def_redis_;
  def_redis_ = NULL;
  return temp;
}
inline void GameServerConfigInfo::set_allocated_def_redis(::RedisConnectOption* def_redis) {
  delete def_redis_;
  def_redis_ = def_redis;
  if (def_redis) {
    set_has_def_redis();
  } else {
    clear_has_def_redis();
  }
  // @@protoc_insertion_point(field_set_allocated:GameServerConfigInfo.def_redis)
}

// repeated .RedisSentinelOption def_sentinel = 18;
inline int GameServerConfigInfo::def_sentinel_size() const {
  return def_sentinel_.size();
}
inline void GameServerConfigInfo::clear_def_sentinel() {
  def_sentinel_.Clear();
}
inline const ::RedisSentinelOption& GameServerConfigInfo::def_sentinel(int index) const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.def_sentinel)
  return def_sentinel_.Get(index);
}
inline ::RedisSentinelOption* GameServerConfigInfo::mutable_def_sentinel(int index) {
  // @@protoc_insertion_point(field_mutable:GameServerConfigInfo.def_sentinel)
  return def_sentinel_.Mutable(index);
}
inline ::RedisSentinelOption* GameServerConfigInfo::add_def_sentinel() {
  // @@protoc_insertion_point(field_add:GameServerConfigInfo.def_sentinel)
  return def_sentinel_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >*
GameServerConfigInfo::mutable_def_sentinel() {
  // @@protoc_insertion_point(field_mutable_list:GameServerConfigInfo.def_sentinel)
  return &def_sentinel_;
}
inline const ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >&
GameServerConfigInfo::def_sentinel() const {
  // @@protoc_insertion_point(field_list:GameServerConfigInfo.def_sentinel)
  return def_sentinel_;
}

// optional int32 bank_transfer_tax = 19;
inline bool GameServerConfigInfo::has_bank_transfer_tax() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GameServerConfigInfo::set_has_bank_transfer_tax() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GameServerConfigInfo::clear_has_bank_transfer_tax() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GameServerConfigInfo::clear_bank_transfer_tax() {
  bank_transfer_tax_ = 0;
  clear_has_bank_transfer_tax();
}
inline ::google::protobuf::int32 GameServerConfigInfo::bank_transfer_tax() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.bank_transfer_tax)
  return bank_transfer_tax_;
}
inline void GameServerConfigInfo::set_bank_transfer_tax(::google::protobuf::int32 value) {
  set_has_bank_transfer_tax();
  bank_transfer_tax_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.bank_transfer_tax)
}

// optional int32 register_money = 20;
inline bool GameServerConfigInfo::has_register_money() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GameServerConfigInfo::set_has_register_money() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GameServerConfigInfo::clear_has_register_money() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GameServerConfigInfo::clear_register_money() {
  register_money_ = 0;
  clear_has_register_money();
}
inline ::google::protobuf::int32 GameServerConfigInfo::register_money() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.register_money)
  return register_money_;
}
inline void GameServerConfigInfo::set_register_money(::google::protobuf::int32 value) {
  set_has_register_money();
  register_money_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.register_money)
}

// optional int32 private_room_bank = 21;
inline bool GameServerConfigInfo::has_private_room_bank() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GameServerConfigInfo::set_has_private_room_bank() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GameServerConfigInfo::clear_has_private_room_bank() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GameServerConfigInfo::clear_private_room_bank() {
  private_room_bank_ = 0;
  clear_has_private_room_bank();
}
inline ::google::protobuf::int32 GameServerConfigInfo::private_room_bank() const {
  // @@protoc_insertion_point(field_get:GameServerConfigInfo.private_room_bank)
  return private_room_bank_;
}
inline void GameServerConfigInfo::set_private_room_bank(::google::protobuf::int32 value) {
  set_has_private_room_bank();
  private_room_bank_ = value;
  // @@protoc_insertion_point(field_set:GameServerConfigInfo.private_room_bank)
}

// -------------------------------------------------------------------

// GateServerConfigInfo

// required int32 gate_id = 1;
inline bool GateServerConfigInfo::has_gate_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GateServerConfigInfo::set_has_gate_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GateServerConfigInfo::clear_has_gate_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GateServerConfigInfo::clear_gate_id() {
  gate_id_ = 0;
  clear_has_gate_id();
}
inline ::google::protobuf::int32 GateServerConfigInfo::gate_id() const {
  // @@protoc_insertion_point(field_get:GateServerConfigInfo.gate_id)
  return gate_id_;
}
inline void GateServerConfigInfo::set_gate_id(::google::protobuf::int32 value) {
  set_has_gate_id();
  gate_id_ = value;
  // @@protoc_insertion_point(field_set:GateServerConfigInfo.gate_id)
}

// required int32 port = 2;
inline bool GateServerConfigInfo::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GateServerConfigInfo::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GateServerConfigInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GateServerConfigInfo::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 GateServerConfigInfo::port() const {
  // @@protoc_insertion_point(field_get:GateServerConfigInfo.port)
  return port_;
}
inline void GateServerConfigInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:GateServerConfigInfo.port)
}

// optional int32 timeout_limit = 3;
inline bool GateServerConfigInfo::has_timeout_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GateServerConfigInfo::set_has_timeout_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GateServerConfigInfo::clear_has_timeout_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GateServerConfigInfo::clear_timeout_limit() {
  timeout_limit_ = 0;
  clear_has_timeout_limit();
}
inline ::google::protobuf::int32 GateServerConfigInfo::timeout_limit() const {
  // @@protoc_insertion_point(field_get:GateServerConfigInfo.timeout_limit)
  return timeout_limit_;
}
inline void GateServerConfigInfo::set_timeout_limit(::google::protobuf::int32 value) {
  set_has_timeout_limit();
  timeout_limit_ = value;
  // @@protoc_insertion_point(field_set:GateServerConfigInfo.timeout_limit)
}

// optional int32 sms_time_limit = 4;
inline bool GateServerConfigInfo::has_sms_time_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GateServerConfigInfo::set_has_sms_time_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GateServerConfigInfo::clear_has_sms_time_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GateServerConfigInfo::clear_sms_time_limit() {
  sms_time_limit_ = 0;
  clear_has_sms_time_limit();
}
inline ::google::protobuf::int32 GateServerConfigInfo::sms_time_limit() const {
  // @@protoc_insertion_point(field_get:GateServerConfigInfo.sms_time_limit)
  return sms_time_limit_;
}
inline void GateServerConfigInfo::set_sms_time_limit(::google::protobuf::int32 value) {
  set_has_sms_time_limit();
  sms_time_limit_ = value;
  // @@protoc_insertion_point(field_set:GateServerConfigInfo.sms_time_limit)
}

// optional string sms_url = 5;
inline bool GateServerConfigInfo::has_sms_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GateServerConfigInfo::set_has_sms_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GateServerConfigInfo::clear_has_sms_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GateServerConfigInfo::clear_sms_url() {
  sms_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sms_url();
}
inline const ::std::string& GateServerConfigInfo::sms_url() const {
  // @@protoc_insertion_point(field_get:GateServerConfigInfo.sms_url)
  return sms_url_.GetNoArena();
}
inline void GateServerConfigInfo::set_sms_url(const ::std::string& value) {
  set_has_sms_url();
  sms_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GateServerConfigInfo.sms_url)
}
#if LANG_CXX11
inline void GateServerConfigInfo::set_sms_url(::std::string&& value) {
  set_has_sms_url();
  sms_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GateServerConfigInfo.sms_url)
}
#endif
inline void GateServerConfigInfo::set_sms_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sms_url();
  sms_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GateServerConfigInfo.sms_url)
}
inline void GateServerConfigInfo::set_sms_url(const char* value, size_t size) {
  set_has_sms_url();
  sms_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GateServerConfigInfo.sms_url)
}
inline ::std::string* GateServerConfigInfo::mutable_sms_url() {
  set_has_sms_url();
  // @@protoc_insertion_point(field_mutable:GateServerConfigInfo.sms_url)
  return sms_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GateServerConfigInfo::release_sms_url() {
  // @@protoc_insertion_point(field_release:GateServerConfigInfo.sms_url)
  clear_has_sms_url();
  return sms_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GateServerConfigInfo::set_allocated_sms_url(::std::string* sms_url) {
  if (sms_url != NULL) {
    set_has_sms_url();
  } else {
    clear_has_sms_url();
  }
  sms_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sms_url);
  // @@protoc_insertion_point(field_set_allocated:GateServerConfigInfo.sms_url)
}

// repeated .NetworkAddress login_addr = 6;
inline int GateServerConfigInfo::login_addr_size() const {
  return login_addr_.size();
}
inline void GateServerConfigInfo::clear_login_addr() {
  login_addr_.Clear();
}
inline const ::NetworkAddress& GateServerConfigInfo::login_addr(int index) const {
  // @@protoc_insertion_point(field_get:GateServerConfigInfo.login_addr)
  return login_addr_.Get(index);
}
inline ::NetworkAddress* GateServerConfigInfo::mutable_login_addr(int index) {
  // @@protoc_insertion_point(field_mutable:GateServerConfigInfo.login_addr)
  return login_addr_.Mutable(index);
}
inline ::NetworkAddress* GateServerConfigInfo::add_login_addr() {
  // @@protoc_insertion_point(field_add:GateServerConfigInfo.login_addr)
  return login_addr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
GateServerConfigInfo::mutable_login_addr() {
  // @@protoc_insertion_point(field_mutable_list:GateServerConfigInfo.login_addr)
  return &login_addr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
GateServerConfigInfo::login_addr() const {
  // @@protoc_insertion_point(field_list:GateServerConfigInfo.login_addr)
  return login_addr_;
}

// repeated .NetworkAddress game_addr = 7;
inline int GateServerConfigInfo::game_addr_size() const {
  return game_addr_.size();
}
inline void GateServerConfigInfo::clear_game_addr() {
  game_addr_.Clear();
}
inline const ::NetworkAddress& GateServerConfigInfo::game_addr(int index) const {
  // @@protoc_insertion_point(field_get:GateServerConfigInfo.game_addr)
  return game_addr_.Get(index);
}
inline ::NetworkAddress* GateServerConfigInfo::mutable_game_addr(int index) {
  // @@protoc_insertion_point(field_mutable:GateServerConfigInfo.game_addr)
  return game_addr_.Mutable(index);
}
inline ::NetworkAddress* GateServerConfigInfo::add_game_addr() {
  // @@protoc_insertion_point(field_add:GateServerConfigInfo.game_addr)
  return game_addr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkAddress >*
GateServerConfigInfo::mutable_game_addr() {
  // @@protoc_insertion_point(field_mutable_list:GateServerConfigInfo.game_addr)
  return &game_addr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkAddress >&
GateServerConfigInfo::game_addr() const {
  // @@protoc_insertion_point(field_list:GateServerConfigInfo.game_addr)
  return game_addr_;
}

// optional string sms_sign_key = 8;
inline bool GateServerConfigInfo::has_sms_sign_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GateServerConfigInfo::set_has_sms_sign_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GateServerConfigInfo::clear_has_sms_sign_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GateServerConfigInfo::clear_sms_sign_key() {
  sms_sign_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sms_sign_key();
}
inline const ::std::string& GateServerConfigInfo::sms_sign_key() const {
  // @@protoc_insertion_point(field_get:GateServerConfigInfo.sms_sign_key)
  return sms_sign_key_.GetNoArena();
}
inline void GateServerConfigInfo::set_sms_sign_key(const ::std::string& value) {
  set_has_sms_sign_key();
  sms_sign_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GateServerConfigInfo.sms_sign_key)
}
#if LANG_CXX11
inline void GateServerConfigInfo::set_sms_sign_key(::std::string&& value) {
  set_has_sms_sign_key();
  sms_sign_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GateServerConfigInfo.sms_sign_key)
}
#endif
inline void GateServerConfigInfo::set_sms_sign_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sms_sign_key();
  sms_sign_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GateServerConfigInfo.sms_sign_key)
}
inline void GateServerConfigInfo::set_sms_sign_key(const char* value, size_t size) {
  set_has_sms_sign_key();
  sms_sign_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GateServerConfigInfo.sms_sign_key)
}
inline ::std::string* GateServerConfigInfo::mutable_sms_sign_key() {
  set_has_sms_sign_key();
  // @@protoc_insertion_point(field_mutable:GateServerConfigInfo.sms_sign_key)
  return sms_sign_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GateServerConfigInfo::release_sms_sign_key() {
  // @@protoc_insertion_point(field_release:GateServerConfigInfo.sms_sign_key)
  clear_has_sms_sign_key();
  return sms_sign_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GateServerConfigInfo::set_allocated_sms_sign_key(::std::string* sms_sign_key) {
  if (sms_sign_key != NULL) {
    set_has_sms_sign_key();
  } else {
    clear_has_sms_sign_key();
  }
  sms_sign_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sms_sign_key);
  // @@protoc_insertion_point(field_set_allocated:GateServerConfigInfo.sms_sign_key)
}

// -------------------------------------------------------------------

// DBServerConfig

// required int32 port = 1;
inline bool DBServerConfig::has_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DBServerConfig::set_has_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DBServerConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DBServerConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 DBServerConfig::port() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.port)
  return port_;
}
inline void DBServerConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:DBServerConfig.port)
}

// required .DBConnectOption login_db = 2;
inline bool DBServerConfig::has_login_db() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBServerConfig::set_has_login_db() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBServerConfig::clear_has_login_db() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBServerConfig::clear_login_db() {
  if (login_db_ != NULL) login_db_->::DBConnectOption::Clear();
  clear_has_login_db();
}
inline const ::DBConnectOption& DBServerConfig::login_db() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.login_db)
  return login_db_ != NULL ? *login_db_
                         : *::DBConnectOption::internal_default_instance();
}
inline ::DBConnectOption* DBServerConfig::mutable_login_db() {
  set_has_login_db();
  if (login_db_ == NULL) {
    login_db_ = new ::DBConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:DBServerConfig.login_db)
  return login_db_;
}
inline ::DBConnectOption* DBServerConfig::release_login_db() {
  // @@protoc_insertion_point(field_release:DBServerConfig.login_db)
  clear_has_login_db();
  ::DBConnectOption* temp = login_db_;
  login_db_ = NULL;
  return temp;
}
inline void DBServerConfig::set_allocated_login_db(::DBConnectOption* login_db) {
  delete login_db_;
  login_db_ = login_db;
  if (login_db) {
    set_has_login_db();
  } else {
    clear_has_login_db();
  }
  // @@protoc_insertion_point(field_set_allocated:DBServerConfig.login_db)
}

// required .DBConnectOption game_db = 3;
inline bool DBServerConfig::has_game_db() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DBServerConfig::set_has_game_db() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DBServerConfig::clear_has_game_db() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DBServerConfig::clear_game_db() {
  if (game_db_ != NULL) game_db_->::DBConnectOption::Clear();
  clear_has_game_db();
}
inline const ::DBConnectOption& DBServerConfig::game_db() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.game_db)
  return game_db_ != NULL ? *game_db_
                         : *::DBConnectOption::internal_default_instance();
}
inline ::DBConnectOption* DBServerConfig::mutable_game_db() {
  set_has_game_db();
  if (game_db_ == NULL) {
    game_db_ = new ::DBConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:DBServerConfig.game_db)
  return game_db_;
}
inline ::DBConnectOption* DBServerConfig::release_game_db() {
  // @@protoc_insertion_point(field_release:DBServerConfig.game_db)
  clear_has_game_db();
  ::DBConnectOption* temp = game_db_;
  game_db_ = NULL;
  return temp;
}
inline void DBServerConfig::set_allocated_game_db(::DBConnectOption* game_db) {
  delete game_db_;
  game_db_ = game_db;
  if (game_db) {
    set_has_game_db();
  } else {
    clear_has_game_db();
  }
  // @@protoc_insertion_point(field_set_allocated:DBServerConfig.game_db)
}

// required .DBConnectOption log_db = 4;
inline bool DBServerConfig::has_log_db() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DBServerConfig::set_has_log_db() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DBServerConfig::clear_has_log_db() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DBServerConfig::clear_log_db() {
  if (log_db_ != NULL) log_db_->::DBConnectOption::Clear();
  clear_has_log_db();
}
inline const ::DBConnectOption& DBServerConfig::log_db() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.log_db)
  return log_db_ != NULL ? *log_db_
                         : *::DBConnectOption::internal_default_instance();
}
inline ::DBConnectOption* DBServerConfig::mutable_log_db() {
  set_has_log_db();
  if (log_db_ == NULL) {
    log_db_ = new ::DBConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:DBServerConfig.log_db)
  return log_db_;
}
inline ::DBConnectOption* DBServerConfig::release_log_db() {
  // @@protoc_insertion_point(field_release:DBServerConfig.log_db)
  clear_has_log_db();
  ::DBConnectOption* temp = log_db_;
  log_db_ = NULL;
  return temp;
}
inline void DBServerConfig::set_allocated_log_db(::DBConnectOption* log_db) {
  delete log_db_;
  log_db_ = log_db;
  if (log_db) {
    set_has_log_db();
  } else {
    clear_has_log_db();
  }
  // @@protoc_insertion_point(field_set_allocated:DBServerConfig.log_db)
}

// required .DBConnectOption recharge_db = 5;
inline bool DBServerConfig::has_recharge_db() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DBServerConfig::set_has_recharge_db() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DBServerConfig::clear_has_recharge_db() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DBServerConfig::clear_recharge_db() {
  if (recharge_db_ != NULL) recharge_db_->::DBConnectOption::Clear();
  clear_has_recharge_db();
}
inline const ::DBConnectOption& DBServerConfig::recharge_db() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.recharge_db)
  return recharge_db_ != NULL ? *recharge_db_
                         : *::DBConnectOption::internal_default_instance();
}
inline ::DBConnectOption* DBServerConfig::mutable_recharge_db() {
  set_has_recharge_db();
  if (recharge_db_ == NULL) {
    recharge_db_ = new ::DBConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:DBServerConfig.recharge_db)
  return recharge_db_;
}
inline ::DBConnectOption* DBServerConfig::release_recharge_db() {
  // @@protoc_insertion_point(field_release:DBServerConfig.recharge_db)
  clear_has_recharge_db();
  ::DBConnectOption* temp = recharge_db_;
  recharge_db_ = NULL;
  return temp;
}
inline void DBServerConfig::set_allocated_recharge_db(::DBConnectOption* recharge_db) {
  delete recharge_db_;
  recharge_db_ = recharge_db;
  if (recharge_db) {
    set_has_recharge_db();
  } else {
    clear_has_recharge_db();
  }
  // @@protoc_insertion_point(field_set_allocated:DBServerConfig.recharge_db)
}

// optional .RedisConnectOption def_redis = 7;
inline bool DBServerConfig::has_def_redis() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DBServerConfig::set_has_def_redis() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DBServerConfig::clear_has_def_redis() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DBServerConfig::clear_def_redis() {
  if (def_redis_ != NULL) def_redis_->::RedisConnectOption::Clear();
  clear_has_def_redis();
}
inline const ::RedisConnectOption& DBServerConfig::def_redis() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.def_redis)
  return def_redis_ != NULL ? *def_redis_
                         : *::RedisConnectOption::internal_default_instance();
}
inline ::RedisConnectOption* DBServerConfig::mutable_def_redis() {
  set_has_def_redis();
  if (def_redis_ == NULL) {
    def_redis_ = new ::RedisConnectOption;
  }
  // @@protoc_insertion_point(field_mutable:DBServerConfig.def_redis)
  return def_redis_;
}
inline ::RedisConnectOption* DBServerConfig::release_def_redis() {
  // @@protoc_insertion_point(field_release:DBServerConfig.def_redis)
  clear_has_def_redis();
  ::RedisConnectOption* temp = def_redis_;
  def_redis_ = NULL;
  return temp;
}
inline void DBServerConfig::set_allocated_def_redis(::RedisConnectOption* def_redis) {
  delete def_redis_;
  def_redis_ = def_redis;
  if (def_redis) {
    set_has_def_redis();
  } else {
    clear_has_def_redis();
  }
  // @@protoc_insertion_point(field_set_allocated:DBServerConfig.def_redis)
}

// repeated .RedisSentinelOption def_sentinel = 8;
inline int DBServerConfig::def_sentinel_size() const {
  return def_sentinel_.size();
}
inline void DBServerConfig::clear_def_sentinel() {
  def_sentinel_.Clear();
}
inline const ::RedisSentinelOption& DBServerConfig::def_sentinel(int index) const {
  // @@protoc_insertion_point(field_get:DBServerConfig.def_sentinel)
  return def_sentinel_.Get(index);
}
inline ::RedisSentinelOption* DBServerConfig::mutable_def_sentinel(int index) {
  // @@protoc_insertion_point(field_mutable:DBServerConfig.def_sentinel)
  return def_sentinel_.Mutable(index);
}
inline ::RedisSentinelOption* DBServerConfig::add_def_sentinel() {
  // @@protoc_insertion_point(field_add:DBServerConfig.def_sentinel)
  return def_sentinel_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >*
DBServerConfig::mutable_def_sentinel() {
  // @@protoc_insertion_point(field_mutable_list:DBServerConfig.def_sentinel)
  return &def_sentinel_;
}
inline const ::google::protobuf::RepeatedPtrField< ::RedisSentinelOption >&
DBServerConfig::def_sentinel() const {
  // @@protoc_insertion_point(field_list:DBServerConfig.def_sentinel)
  return def_sentinel_;
}

// optional int32 init_money = 9;
inline bool DBServerConfig::has_init_money() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DBServerConfig::set_has_init_money() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DBServerConfig::clear_has_init_money() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DBServerConfig::clear_init_money() {
  init_money_ = 0;
  clear_has_init_money();
}
inline ::google::protobuf::int32 DBServerConfig::init_money() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.init_money)
  return init_money_;
}
inline void DBServerConfig::set_init_money(::google::protobuf::int32 value) {
  set_has_init_money();
  init_money_ = value;
  // @@protoc_insertion_point(field_set:DBServerConfig.init_money)
}

// optional string php_sign_key = 10;
inline bool DBServerConfig::has_php_sign_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBServerConfig::set_has_php_sign_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBServerConfig::clear_has_php_sign_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBServerConfig::clear_php_sign_key() {
  php_sign_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_php_sign_key();
}
inline const ::std::string& DBServerConfig::php_sign_key() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.php_sign_key)
  return php_sign_key_.GetNoArena();
}
inline void DBServerConfig::set_php_sign_key(const ::std::string& value) {
  set_has_php_sign_key();
  php_sign_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DBServerConfig.php_sign_key)
}
#if LANG_CXX11
inline void DBServerConfig::set_php_sign_key(::std::string&& value) {
  set_has_php_sign_key();
  php_sign_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DBServerConfig.php_sign_key)
}
#endif
inline void DBServerConfig::set_php_sign_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_php_sign_key();
  php_sign_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DBServerConfig.php_sign_key)
}
inline void DBServerConfig::set_php_sign_key(const char* value, size_t size) {
  set_has_php_sign_key();
  php_sign_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DBServerConfig.php_sign_key)
}
inline ::std::string* DBServerConfig::mutable_php_sign_key() {
  set_has_php_sign_key();
  // @@protoc_insertion_point(field_mutable:DBServerConfig.php_sign_key)
  return php_sign_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBServerConfig::release_php_sign_key() {
  // @@protoc_insertion_point(field_release:DBServerConfig.php_sign_key)
  clear_has_php_sign_key();
  return php_sign_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBServerConfig::set_allocated_php_sign_key(::std::string* php_sign_key) {
  if (php_sign_key != NULL) {
    set_has_php_sign_key();
  } else {
    clear_has_php_sign_key();
  }
  php_sign_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), php_sign_key);
  // @@protoc_insertion_point(field_set_allocated:DBServerConfig.php_sign_key)
}

// optional int32 bank_transfer_tax = 11;
inline bool DBServerConfig::has_bank_transfer_tax() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DBServerConfig::set_has_bank_transfer_tax() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DBServerConfig::clear_has_bank_transfer_tax() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DBServerConfig::clear_bank_transfer_tax() {
  bank_transfer_tax_ = 0;
  clear_has_bank_transfer_tax();
}
inline ::google::protobuf::int32 DBServerConfig::bank_transfer_tax() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.bank_transfer_tax)
  return bank_transfer_tax_;
}
inline void DBServerConfig::set_bank_transfer_tax(::google::protobuf::int32 value) {
  set_has_bank_transfer_tax();
  bank_transfer_tax_ = value;
  // @@protoc_insertion_point(field_set:DBServerConfig.bank_transfer_tax)
}

// optional string php_interface_addr = 12;
inline bool DBServerConfig::has_php_interface_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBServerConfig::set_has_php_interface_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBServerConfig::clear_has_php_interface_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBServerConfig::clear_php_interface_addr() {
  php_interface_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_php_interface_addr();
}
inline const ::std::string& DBServerConfig::php_interface_addr() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.php_interface_addr)
  return php_interface_addr_.GetNoArena();
}
inline void DBServerConfig::set_php_interface_addr(const ::std::string& value) {
  set_has_php_interface_addr();
  php_interface_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DBServerConfig.php_interface_addr)
}
#if LANG_CXX11
inline void DBServerConfig::set_php_interface_addr(::std::string&& value) {
  set_has_php_interface_addr();
  php_interface_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DBServerConfig.php_interface_addr)
}
#endif
inline void DBServerConfig::set_php_interface_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_php_interface_addr();
  php_interface_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DBServerConfig.php_interface_addr)
}
inline void DBServerConfig::set_php_interface_addr(const char* value, size_t size) {
  set_has_php_interface_addr();
  php_interface_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DBServerConfig.php_interface_addr)
}
inline ::std::string* DBServerConfig::mutable_php_interface_addr() {
  set_has_php_interface_addr();
  // @@protoc_insertion_point(field_mutable:DBServerConfig.php_interface_addr)
  return php_interface_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBServerConfig::release_php_interface_addr() {
  // @@protoc_insertion_point(field_release:DBServerConfig.php_interface_addr)
  clear_has_php_interface_addr();
  return php_interface_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBServerConfig::set_allocated_php_interface_addr(::std::string* php_interface_addr) {
  if (php_interface_addr != NULL) {
    set_has_php_interface_addr();
  } else {
    clear_has_php_interface_addr();
  }
  php_interface_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), php_interface_addr);
  // @@protoc_insertion_point(field_set_allocated:DBServerConfig.php_interface_addr)
}

// optional string cash_money_addr = 13;
inline bool DBServerConfig::has_cash_money_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBServerConfig::set_has_cash_money_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBServerConfig::clear_has_cash_money_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBServerConfig::clear_cash_money_addr() {
  cash_money_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cash_money_addr();
}
inline const ::std::string& DBServerConfig::cash_money_addr() const {
  // @@protoc_insertion_point(field_get:DBServerConfig.cash_money_addr)
  return cash_money_addr_.GetNoArena();
}
inline void DBServerConfig::set_cash_money_addr(const ::std::string& value) {
  set_has_cash_money_addr();
  cash_money_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DBServerConfig.cash_money_addr)
}
#if LANG_CXX11
inline void DBServerConfig::set_cash_money_addr(::std::string&& value) {
  set_has_cash_money_addr();
  cash_money_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DBServerConfig.cash_money_addr)
}
#endif
inline void DBServerConfig::set_cash_money_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cash_money_addr();
  cash_money_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DBServerConfig.cash_money_addr)
}
inline void DBServerConfig::set_cash_money_addr(const char* value, size_t size) {
  set_has_cash_money_addr();
  cash_money_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DBServerConfig.cash_money_addr)
}
inline ::std::string* DBServerConfig::mutable_cash_money_addr() {
  set_has_cash_money_addr();
  // @@protoc_insertion_point(field_mutable:DBServerConfig.cash_money_addr)
  return cash_money_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DBServerConfig::release_cash_money_addr() {
  // @@protoc_insertion_point(field_release:DBServerConfig.cash_money_addr)
  clear_has_cash_money_addr();
  return cash_money_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DBServerConfig::set_allocated_cash_money_addr(::std::string* cash_money_addr) {
  if (cash_money_addr != NULL) {
    set_has_cash_money_addr();
  } else {
    clear_has_cash_money_addr();
  }
  cash_money_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cash_money_addr);
  // @@protoc_insertion_point(field_set_allocated:DBServerConfig.cash_money_addr)
}

// -------------------------------------------------------------------

// PrivateRoomInfoConfig

// optional int32 game_id = 1;
inline bool PrivateRoomInfoConfig::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrivateRoomInfoConfig::set_has_game_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrivateRoomInfoConfig::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrivateRoomInfoConfig::clear_game_id() {
  game_id_ = 0;
  clear_has_game_id();
}
inline ::google::protobuf::int32 PrivateRoomInfoConfig::game_id() const {
  // @@protoc_insertion_point(field_get:PrivateRoomInfoConfig.game_id)
  return game_id_;
}
inline void PrivateRoomInfoConfig::set_game_id(::google::protobuf::int32 value) {
  set_has_game_id();
  game_id_ = value;
  // @@protoc_insertion_point(field_set:PrivateRoomInfoConfig.game_id)
}

// optional int32 first_game_type = 2;
inline bool PrivateRoomInfoConfig::has_first_game_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrivateRoomInfoConfig::set_has_first_game_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrivateRoomInfoConfig::clear_has_first_game_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrivateRoomInfoConfig::clear_first_game_type() {
  first_game_type_ = 0;
  clear_has_first_game_type();
}
inline ::google::protobuf::int32 PrivateRoomInfoConfig::first_game_type() const {
  // @@protoc_insertion_point(field_get:PrivateRoomInfoConfig.first_game_type)
  return first_game_type_;
}
inline void PrivateRoomInfoConfig::set_first_game_type(::google::protobuf::int32 value) {
  set_has_first_game_type();
  first_game_type_ = value;
  // @@protoc_insertion_point(field_set:PrivateRoomInfoConfig.first_game_type)
}

// optional string room_lua_cfg = 3;
inline bool PrivateRoomInfoConfig::has_room_lua_cfg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrivateRoomInfoConfig::set_has_room_lua_cfg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrivateRoomInfoConfig::clear_has_room_lua_cfg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrivateRoomInfoConfig::clear_room_lua_cfg() {
  room_lua_cfg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_room_lua_cfg();
}
inline const ::std::string& PrivateRoomInfoConfig::room_lua_cfg() const {
  // @@protoc_insertion_point(field_get:PrivateRoomInfoConfig.room_lua_cfg)
  return room_lua_cfg_.GetNoArena();
}
inline void PrivateRoomInfoConfig::set_room_lua_cfg(const ::std::string& value) {
  set_has_room_lua_cfg();
  room_lua_cfg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PrivateRoomInfoConfig.room_lua_cfg)
}
#if LANG_CXX11
inline void PrivateRoomInfoConfig::set_room_lua_cfg(::std::string&& value) {
  set_has_room_lua_cfg();
  room_lua_cfg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PrivateRoomInfoConfig.room_lua_cfg)
}
#endif
inline void PrivateRoomInfoConfig::set_room_lua_cfg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_room_lua_cfg();
  room_lua_cfg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PrivateRoomInfoConfig.room_lua_cfg)
}
inline void PrivateRoomInfoConfig::set_room_lua_cfg(const char* value, size_t size) {
  set_has_room_lua_cfg();
  room_lua_cfg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PrivateRoomInfoConfig.room_lua_cfg)
}
inline ::std::string* PrivateRoomInfoConfig::mutable_room_lua_cfg() {
  set_has_room_lua_cfg();
  // @@protoc_insertion_point(field_mutable:PrivateRoomInfoConfig.room_lua_cfg)
  return room_lua_cfg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateRoomInfoConfig::release_room_lua_cfg() {
  // @@protoc_insertion_point(field_release:PrivateRoomInfoConfig.room_lua_cfg)
  clear_has_room_lua_cfg();
  return room_lua_cfg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateRoomInfoConfig::set_allocated_room_lua_cfg(::std::string* room_lua_cfg) {
  if (room_lua_cfg != NULL) {
    set_has_room_lua_cfg();
  } else {
    clear_has_room_lua_cfg();
  }
  room_lua_cfg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), room_lua_cfg);
  // @@protoc_insertion_point(field_set_allocated:PrivateRoomInfoConfig.room_lua_cfg)
}

// -------------------------------------------------------------------

// PrivateRoomListConfig

// repeated .PrivateRoomInfoConfig info = 1;
inline int PrivateRoomListConfig::info_size() const {
  return info_.size();
}
inline void PrivateRoomListConfig::clear_info() {
  info_.Clear();
}
inline const ::PrivateRoomInfoConfig& PrivateRoomListConfig::info(int index) const {
  // @@protoc_insertion_point(field_get:PrivateRoomListConfig.info)
  return info_.Get(index);
}
inline ::PrivateRoomInfoConfig* PrivateRoomListConfig::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:PrivateRoomListConfig.info)
  return info_.Mutable(index);
}
inline ::PrivateRoomInfoConfig* PrivateRoomListConfig::add_info() {
  // @@protoc_insertion_point(field_add:PrivateRoomListConfig.info)
  return info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PrivateRoomInfoConfig >*
PrivateRoomListConfig::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:PrivateRoomListConfig.info)
  return &info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PrivateRoomInfoConfig >&
PrivateRoomListConfig::info() const {
  // @@protoc_insertion_point(field_list:PrivateRoomListConfig.info)
  return info_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_config_2eproto__INCLUDED
